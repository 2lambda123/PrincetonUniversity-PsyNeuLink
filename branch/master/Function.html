

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Functions &mdash; PsyNeuLink 0.3.2 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="PsyNeuLink 0.3.2 documentation" href="index.html"/>
        <link rel="up" title="Components" href="Component.html"/>
        <link rel="next" title="Compositions" href="Composition.html"/>
        <link rel="prev" title="GatingSignal" href="GatingSignal.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> PsyNeuLink
          

          
          </a>

          
            
            
              <div class="version">
                0.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">Welcome to PsyNeuLink</a></li>
<li class="toctree-l1"><a class="reference internal" href="BasicsAndSampler.html">Basics and Sampler</a></li>
<li class="toctree-l1"><a class="reference internal" href="QuickReference.html">Quick Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Core.html">Core</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="Component.html">Components</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="Mechanism.html">Mechanisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="Projection.html">Projections</a></li>
<li class="toctree-l3"><a class="reference internal" href="State.html">States</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Functions</a><ul class="simple">
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Composition.html">Compositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Scheduling.html">Scheduling</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Library.html">Library</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PsyNeuLink</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="Core.html">Core</a> &raquo;</li>
        
          <li><a href="Component.html">Components</a> &raquo;</li>
        
      <li>Functions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/Function.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="functions">
<h1>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">Â¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<span class="target" id="module-Function"></span><dl class="docutils">
<dt>Example function:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#Function.ArgumentTherapy" title="Function.ArgumentTherapy"><code class="xref any py py-class docutils literal"><span class="pre">ArgumentTherapy</span></code></a></li>
</ul>
</dd>
<dt>Combination Functions:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#Function.Reduce" title="Function.Reduce"><code class="xref any py py-class docutils literal"><span class="pre">Reduce</span></code></a></li>
<li><a class="reference internal" href="#Function.LinearCombination" title="Function.LinearCombination"><code class="xref any py py-class docutils literal"><span class="pre">LinearCombination</span></code></a></li>
<li><code class="xref any docutils literal"><span class="pre">CombineMeans</span></code></li>
</ul>
</dd>
<dt>TransferMechanism Functions:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#Function.Linear" title="Function.Linear"><code class="xref any py py-class docutils literal"><span class="pre">Linear</span></code></a></li>
<li><a class="reference internal" href="#Function.Exponential" title="Function.Exponential"><code class="xref any py py-class docutils literal"><span class="pre">Exponential</span></code></a></li>
<li><a class="reference internal" href="#Function.Logistic" title="Function.Logistic"><code class="xref any py py-class docutils literal"><span class="pre">Logistic</span></code></a></li>
<li><a class="reference internal" href="#Function.SoftMax" title="Function.SoftMax"><code class="xref any py py-class docutils literal"><span class="pre">SoftMax</span></code></a></li>
<li><a class="reference internal" href="#Function.LinearMatrix" title="Function.LinearMatrix"><code class="xref any py py-class docutils literal"><span class="pre">LinearMatrix</span></code></a></li>
</ul>
</dd>
<dt>Integrator Functions:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#Function.Integrator" title="Function.Integrator"><code class="xref any py py-class docutils literal"><span class="pre">Integrator</span></code></a></li>
<li><a class="reference internal" href="#Function.SimpleIntegrator" title="Function.SimpleIntegrator"><code class="xref any py py-class docutils literal"><span class="pre">SimpleIntegrator</span></code></a></li>
<li><a class="reference internal" href="#Function.ConstantIntegrator" title="Function.ConstantIntegrator"><code class="xref any py py-class docutils literal"><span class="pre">ConstantIntegrator</span></code></a></li>
<li><a class="reference internal" href="#Function.AdaptiveIntegrator" title="Function.AdaptiveIntegrator"><code class="xref any py py-class docutils literal"><span class="pre">AdaptiveIntegrator</span></code></a></li>
<li><a class="reference internal" href="#Function.DriftDiffusionIntegrator" title="Function.DriftDiffusionIntegrator"><code class="xref any py py-class docutils literal"><span class="pre">DriftDiffusionIntegrator</span></code></a></li>
<li><a class="reference internal" href="#Function.OrnsteinUhlenbeckIntegrator" title="Function.OrnsteinUhlenbeckIntegrator"><code class="xref any py py-class docutils literal"><span class="pre">OrnsteinUhlenbeckIntegrator</span></code></a></li>
<li><a class="reference internal" href="#Function.AccumulatorIntegrator" title="Function.AccumulatorIntegrator"><code class="xref any py py-class docutils literal"><span class="pre">AccumulatorIntegrator</span></code></a></li>
<li><a class="reference internal" href="#Function.FHNIntegrator" title="Function.FHNIntegrator"><code class="xref any py py-class docutils literal"><span class="pre">FHNIntegrator</span></code></a></li>
<li><a class="reference internal" href="#Function.AGTUtilityIntegrator" title="Function.AGTUtilityIntegrator"><code class="xref any py py-class docutils literal"><span class="pre">AGTUtilityIntegrator</span></code></a></li>
<li><a class="reference internal" href="#Function.BogaczEtAl" title="Function.BogaczEtAl"><code class="xref any py py-class docutils literal"><span class="pre">BogaczEtAl</span></code></a></li>
<li><a class="reference internal" href="#Function.NavarroAndFuss" title="Function.NavarroAndFuss"><code class="xref any py py-class docutils literal"><span class="pre">NavarroAndFuss</span></code></a></li>
</ul>
</dd>
<dt>Distribution Functions:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#Function.NormalDist" title="Function.NormalDist"><code class="xref any py py-class docutils literal"><span class="pre">NormalDist</span></code></a></li>
<li><a class="reference internal" href="#Function.ExponentialDist" title="Function.ExponentialDist"><code class="xref any py py-class docutils literal"><span class="pre">ExponentialDist</span></code></a></li>
<li><a class="reference internal" href="#Function.UniformDist" title="Function.UniformDist"><code class="xref any py py-class docutils literal"><span class="pre">UniformDist</span></code></a></li>
<li><a class="reference internal" href="#Function.GammaDist" title="Function.GammaDist"><code class="xref any py py-class docutils literal"><span class="pre">GammaDist</span></code></a></li>
<li><a class="reference internal" href="#Function.WaldDist" title="Function.WaldDist"><code class="xref any py py-class docutils literal"><span class="pre">WaldDist</span></code></a></li>
</ul>
</dd>
<dt>Objective Functions:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#Function.Stability" title="Function.Stability"><code class="xref any py py-class docutils literal"><span class="pre">Stability</span></code></a></li>
<li><a class="reference internal" href="#Function.Distance" title="Function.Distance"><code class="xref any py py-class docutils literal"><span class="pre">Distance</span></code></a></li>
</ul>
</dd>
<dt>Learning Functions:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#Function.Reinforcement" title="Function.Reinforcement"><code class="xref any py py-class docutils literal"><span class="pre">Reinforcement</span></code></a></li>
<li><a class="reference internal" href="#Function.BackPropagation" title="Function.BackPropagation"><code class="xref any py py-class docutils literal"><span class="pre">BackPropagation</span></code></a></li>
</ul>
</dd>
</dl>
<div class="section" id="overview">
<span id="function-overview"></span><h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">Â¶</a></h2>
<p>A Function is a <a class="reference internal" href="Component.html"><span class="doc">Component</span></a> that âpackagesâ a function (in its <a class="reference internal" href="#Function.Function_Base.function" title="Function.Function_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a> method)
for use by other Components.  Every Component in PsyNeuLink is assigned a Function; when that Component is executed, its
Functionâs <a class="reference internal" href="#Function.Function_Base.function" title="Function.Function_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a> is executed.  The <a class="reference internal" href="#Function.Function_Base.function" title="Function.Function_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a> can be any callable
operation, although most commonly it is a mathematical operation (and, for those, almost always uses a call to one or
more numpy functions).  There are two reasons PsyNeuLink packages functions in a Function Component:</p>
<ul class="simple">
<li><strong>Manage parameters</strong> â parameters are attributes of a Function that either remain stable over multiple calls to the
function (e.g., the <a class="reference internal" href="#Function.Logistic.gain" title="Function.Logistic.gain"><code class="xref any py py-attr docutils literal"><span class="pre">gain</span></code></a> or <a class="reference internal" href="#Function.Logistic.bias" title="Function.Logistic.bias"><code class="xref any py py-attr docutils literal"><span class="pre">bias</span></code></a> of a <a class="reference internal" href="#Function.Logistic" title="Function.Logistic"><code class="xref any py py-class docutils literal"><span class="pre">Logistic</span></code></a> function, or the learning rate
of a learning function); or, if they change, they do so less frequently or under the control of different factors
than the functionâs variable (i.e., its input).  As a consequence, it is useful to manage these separately from the
functionâs variable, and not have to provide them every time the function is called.  To address this, every
PsyNeuLink Function has a set of attributes corresponding to the parameters of the function, that can be specified at
the time the Function is created (in arguments to its constructor), and can be modified independently
of a call to its <code class="xref std std-keyword docutils literal"><span class="pre">function</span></code>. Modifications can be directly (e.g., in a script), or by the operation of other
PsyNeuLink Components (e.g., <a class="reference internal" href="AdaptiveMechanisms.html"><span class="doc">AdaptiveMechanisms</span></a>) by way of <a class="reference internal" href="ControlProjection.html"><span class="doc">ControlProjections</span></a>.</li>
</ul>
<ul class="simple">
<li><strong>Modularity</strong> â by providing a standard interface, any Function assigned to a Components in PsyNeuLink can be
replaced with other PsyNeuLink Functions, or with user-written custom functions so long as they adhere to certain
standards (the PsyNeuLink <span class="xref std std-ref">Function API</span>).</li>
</ul>
</div>
<div class="section" id="creating-a-function">
<span id="function-creation"></span><h2>Creating a Function<a class="headerlink" href="#creating-a-function" title="Permalink to this headline">Â¶</a></h2>
<p>A Function can be created directly by calling its constructor.  Functions are also created automatically whenever
any other type of PsyNeuLink Component is created (and its <code class="xref std std-keyword docutils literal"><span class="pre">function</span></code> is not otherwise specified). The
constructor for a Function has an argument for its <a class="reference internal" href="#Function.Function_Base.variable" title="Function.Function_Base.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> and each of the parameters of
its <a class="reference internal" href="#Function.Function_Base.function" title="Function.Function_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a>.  The <a class="reference internal" href="#Function.Function_Base.variable" title="Function.Function_Base.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> argument is used both to format the
input to the <a class="reference internal" href="#Function.Function_Base.function" title="Function.Function_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a>, and assign its default value.  The arguments for each parameter can
be used to specify the default value for that parameter; the values can later be modified in various ways as described
below.</p>
</div>
<div class="section" id="structure">
<span id="function-structure"></span><h2>Structure<a class="headerlink" href="#structure" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="core-attributes">
<span id="function-core-attributes"></span><h3>Core Attributes<a class="headerlink" href="#core-attributes" title="Permalink to this headline">Â¶</a></h3>
<p>Every Function has the following core attributes:</p>
<ul class="simple">
<li><a class="reference internal" href="#Function.Function_Base.variable" title="Function.Function_Base.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> â provides the input to the Functionâs <a class="reference internal" href="#Function.Function_Base.function" title="Function.Function_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a>.</li>
</ul>
<ul class="simple">
<li><a class="reference internal" href="#Function.Function_Base.function" title="Function.Function_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a> â determines the computation carried out by the Function; it must be a
callable object (that is, a python function or method of some kind). Unlike other PsyNeuLink <a class="reference internal" href="Component.html"><span class="doc">Components</span></a>, it <em>cannot</em> be (another) Function object (it canât be âturtlesâ all the way down!). If the Function
has been assigned to another <a class="reference internal" href="Component.html"><span class="doc">Components</span></a>, then its <a class="reference internal" href="#Function.Function_Base.function" title="Function.Function_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a> is also assigned as the
the <a class="reference internal" href="Component.html#Component.Component.function" title="Component.Component.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a> attribute of the Component to which it has been assigned (i.e., its
<a class="reference internal" href="#Function.Function_Base.owner" title="Function.Function_Base.owner"><code class="xref any py py-attr docutils literal"><span class="pre">owner</span></code></a>.</li>
</ul>
<p>A Function also has an attribute for each of the parameters of its <a class="reference internal" href="#Function.Function_Base.function" title="Function.Function_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a>.</p>
</div>
<div class="section" id="owner">
<h3>Owner<a class="headerlink" href="#owner" title="Permalink to this headline">Â¶</a></h3>
<p>If a Function has been assigned to another <a class="reference internal" href="Component.html"><span class="doc">Components</span></a>, then it also has an <a class="reference internal" href="#Function.Function_Base.owner" title="Function.Function_Base.owner"><code class="xref any py py-attr docutils literal"><span class="pre">owner</span></code></a> attribute
that refers to that Component.  The Function itself is assigned as the Componentâs
<a class="reference internal" href="Component.html#Component.Component.function_object" title="Component.Component.function_object"><code class="xref any py py-attr docutils literal"><span class="pre">function_object</span></code></a> attribute.  Each of the Functionâs attributes is also assigned
as an attribute of the <a class="reference internal" href="#Function.Function_Base.owner" title="Function.Function_Base.owner"><code class="xref any py py-attr docutils literal"><span class="pre">owner</span></code></a>, and those are each associated with with a
<a class="reference internal" href="ParameterState.html"><span class="doc">parameterState</span></a> of the <a class="reference internal" href="#Function.Function_Base.owner" title="Function.Function_Base.owner"><code class="xref any py py-attr docutils literal"><span class="pre">owner</span></code></a>.  Projections to those parameterStates can be
used by <a class="reference internal" href="ControlProjection.html"><span class="doc">ControlProjections</span></a> to modify the Functionâs parameters.</p>
</div>
<div class="section" id="modulatory-parameters">
<span id="function-modulatory-params"></span><h3>Modulatory Parameters<a class="headerlink" href="#modulatory-parameters" title="Permalink to this headline">Â¶</a></h3>
<p>Some classes of Functions also implement a pair of modulatory parameters: <code class="xref any docutils literal"><span class="pre">multiplicative_param</span></code> and <code class="xref any docutils literal"><span class="pre">additive_param</span></code>.
Each of these is assigned the name of one of the functionâs parameters. These are used by <a class="reference internal" href="ModulatorySignal.html"><span class="doc">ModulatorySignals</span></a> to modulate the output of the function (see <a class="reference internal" href="ModulatorySignal.html#modulatorysignal-detail-figure"><span class="std std-ref">figure</span></a>).  For
example, they are used by <a class="reference internal" href="GatingSignal.html"><span class="doc">GatingSignals</span></a> to modulate the <a class="reference internal" href="State.html#State.State_Base.function" title="State.State_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a> of an
<a class="reference internal" href="InputState.html"><span class="doc">InputState</span></a> or <a class="reference internal" href="OutputState.html"><span class="doc">OutputState</span></a>, and thereby its <a class="reference internal" href="State.html#State.State_Base.value" title="State.State_Base.value"><code class="xref any py py-attr docutils literal"><span class="pre">value</span></code></a>; and by the <a class="reference internal" href="ControlSignal.html"><span class="doc">ControlSignal(s)</span></a>
of an <a class="reference internal" href="LCControlMechanism.html"><span class="doc">LCControlMechanism</span></a> to modulate the <code class="xref any docutils literal"><span class="pre">multiplicative_param</span></code> of the <a class="reference internal" href="TransferMechanism.html#TransferMechanism.TransferMechanism.function" title="TransferMechanism.TransferMechanism.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a> of a
<a class="reference internal" href="TransferMechanism.html"><span class="doc">TransferMechanism</span></a>.</p>
</div>
</div>
<div class="section" id="execution">
<span id="function-execution"></span><h2>Execution<a class="headerlink" href="#execution" title="Permalink to this headline">Â¶</a></h2>
<p>Functions are not executable objects, but their <a class="reference internal" href="#Function.Function_Base.function" title="Function.Function_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a> can be called.   This can be done
directly.  More commonly, however, they are called when their <a class="reference internal" href="#Function.Function_Base.owner" title="Function.Function_Base.owner"><code class="xref any py py-attr docutils literal"><span class="pre">owner</span></code></a> is executed.  The parameters
of the <a class="reference internal" href="#Function.Function_Base.function" title="Function.Function_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a> can be modified when it is executed, by assigning a
<a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter specification dictionary</span></a> to the <strong>params</strong> argument in the
call to the <a class="reference internal" href="#Function.Function_Base.function" title="Function.Function_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a>.  For <a class="reference internal" href="Mechanism.html"><span class="doc">Mechanisms</span></a>, this can also be done by specifying
<a class="reference internal" href="Mechanism.html#mechanism-runtime-parameters"><span class="std std-ref">runtime_params</span></a> for the Mechanism when it is <a class="reference internal" href="Mechanism.html#Mechanism.Mechanism_Base.execute" title="Mechanism.Mechanism_Base.execute"><code class="xref any py py-meth docutils literal"><span class="pre">executed</span></code></a>.</p>
</div>
<div class="section" id="class-reference">
<h2>Class Reference<a class="headerlink" href="#class-reference" title="Permalink to this headline">Â¶</a></h2>
<dl class="class">
<dt id="Function.ModulationParam">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">ModulationParam</code><a class="headerlink" href="#Function.ModulationParam" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Specify parameter of a <a class="reference internal" href="#"><span class="doc">Function</span></a> for <a class="reference internal" href="ModulatorySignal.html#modulatorysignal-modulation"><span class="std std-ref">modulation</span></a> by a ModulatorySignal</p>
<dl class="attribute">
<dt id="Function.ModulationParam.MULTIPLICATIVE">
<code class="descname">MULTIPLICATIVE</code><a class="headerlink" href="#Function.ModulationParam.MULTIPLICATIVE" title="Permalink to this definition">Â¶</a></dt>
<dd><p>assign the <a class="reference internal" href="ModulatorySignal.html#ModulatorySignals.ModulatorySignal.ModulatorySignal.value" title="ModulatorySignals.ModulatorySignal.ModulatorySignal.value"><code class="xref any py py-attr docutils literal"><span class="pre">value</span></code></a> of the ModulatorySignal to the <em>MULTIPLICATIVE_PARAM</em>
of the Stateâs <a class="reference internal" href="State.html#State.State_Base.function" title="State.State_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="Function.ModulationParam.ADDITIVE">
<code class="descname">ADDITIVE</code><a class="headerlink" href="#Function.ModulationParam.ADDITIVE" title="Permalink to this definition">Â¶</a></dt>
<dd><p>assign the <a class="reference internal" href="ModulatorySignal.html#ModulatorySignals.ModulatorySignal.ModulatorySignal.value" title="ModulatorySignals.ModulatorySignal.ModulatorySignal.value"><code class="xref any py py-attr docutils literal"><span class="pre">value</span></code></a> of the ModulatorySignal to the <em>ADDITIVE_PARAM</em>
of the Stateâs <a class="reference internal" href="State.html#State.State_Base.function" title="State.State_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="Function.ModulationParam.OVERRIDE">
<code class="descname">OVERRIDE</code><a class="headerlink" href="#Function.ModulationParam.OVERRIDE" title="Permalink to this definition">Â¶</a></dt>
<dd><p>assign the <a class="reference internal" href="ModulatorySignal.html#ModulatorySignals.ModulatorySignal.ModulatorySignal.value" title="ModulatorySignals.ModulatorySignal.ModulatorySignal.value"><code class="xref any py py-attr docutils literal"><span class="pre">value</span></code></a> of the ModulatorySignal directly to the Stateâs
<a class="reference internal" href="State.html#State.State_Base.value" title="State.State_Base.value"><code class="xref any py py-attr docutils literal"><span class="pre">value</span></code></a> (ignoring its <code class="xref any docutils literal"><span class="pre">variable</span></code> and <a class="reference internal" href="State.html#State.State_Base.function" title="State.State_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a>)</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.ModulationParam.DISABLE">
<code class="descname">DISABLE</code><a class="headerlink" href="#Function.ModulationParam.DISABLE" title="Permalink to this definition">Â¶</a></dt>
<dd><p>ignore the ModulatorySignal when calculating the Stateâs <a class="reference internal" href="State.html#State.State_Base.value" title="State.State_Base.value"><code class="xref any py py-attr docutils literal"><span class="pre">value</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.Function_Base">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Function_Base</code><span class="sig-paren">(</span><em>default_variable</em>, <em>params=None</em>, <em>owner=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Function_Base" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Implement abstract class for Function category of Component class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>value : default ClassDefaults.variable</em>) â specifies the format and a default value for the input to <a class="reference internal" href="#"><span class="doc">function</span></a>.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.Function_Base.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.Function_Base.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>value</em> â format and default value can be specified by the <code class="xref std std-keyword docutils literal"><span class="pre">variable</span></code> argument of the constructor;  otherwise,
they are specified by the Functionâs <code class="xref std std-keyword docutils literal"><span class="pre">ClassDefaults.variable</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Function_Base.function">
<code class="descname">function</code><a class="headerlink" href="#Function.Function_Base.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>function</em> â called by the Functionâs <a class="reference internal" href="#Function.Function_Base.owner" title="Function.Function_Base.owner"><code class="xref any py py-attr docutils literal"><span class="pre">owner</span></code></a> when it is executed.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Function_Base.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.Function_Base.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Mechanism</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Function_Base.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.Function_Base.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.ArgumentTherapy">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">ArgumentTherapy</code><span class="sig-paren">(</span><em>variable</em>, <em>propensity=Manner.CONTRARIAN</em>, <em>pertinacity=10.0                       params=None</em>, <em>owner=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.ArgumentTherapy" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="argumenttherapist">Return <code class="xref any docutils literal"><span class="pre">True</span></code> or <code class="xref std std-keyword docutils literal"><span class="pre">False</span></code> according to the manner of the therapist.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>boolean</em><em> or </em><em>statement that resolves to one : default ClassDefaults.variable</em>) â assertion for which a therapeutic response will be offered.</li>
<li><strong>propensity</strong> (<em>Manner value : default Manner.CONTRARIAN</em>) â specifies preferred therapeutic manner</li>
<li><strong>pertinacity</strong> (<em>float : default 10.0</em>) â specifies therapeutic consistency</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.ArgumentTherapy.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.ArgumentTherapy.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>boolean</em> â assertion to which a therapeutic response is made.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.ArgumentTherapy.propensity">
<code class="descname">propensity</code><a class="headerlink" href="#Function.ArgumentTherapy.propensity" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Manner value : default Manner.CONTRARIAN</em> â determines therapeutic manner:  tendency to agree or disagree.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.ArgumentTherapy.pertinacity">
<code class="descname">pertinacity</code><a class="headerlink" href="#Function.ArgumentTherapy.pertinacity" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 10.0</em> â determines consistency with which the manner complies with the propensity.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.ArgumentTherapy.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.ArgumentTherapy.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Mechanism</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.ArgumentTherapy.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.ArgumentTherapy.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="class">
<dt id="Function.ArgumentTherapy.Manner">
<em class="property">class </em><code class="descname">Manner</code><a class="headerlink" href="#Function.ArgumentTherapy.Manner" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An enumeration.</p>
</dd></dl>

<dl class="method">
<dt id="Function.ArgumentTherapy.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 2&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.ArgumentTherapy.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns a boolean that is (or tends to be) the same as or opposite the one passed in.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>boolean : default ClassDefaults.variable</em>) â an assertion to which a therapeutic response is made.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) â specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>therapeutic response</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">boolean</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.UserDefinedFunction">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">UserDefinedFunction</code><span class="sig-paren">(</span><em>function</em>, <em>variable=None</em>, <em>params=None</em>, <em>owner=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.UserDefinedFunction" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Implement user-defined Function.</p>
<p>This is used to âwrapâ custom functions in the PsyNeuLink <code class="xref any docutils literal"><span class="pre">Function</span> <span class="pre">API</span></code>.
It is automatically invoked and applied to any function that is assigned to the <a class="reference internal" href="Component.html#Component.Component.function" title="Component.Component.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a>
attribute of a PsyNeuLink component (other than a Function itself).  The function can take any arguments and
return any values.  However, if UserDefinedFunction is used to create a custom version of another PsyNeuLink
<a class="reference internal" href="#"><span class="doc">Function</span></a>, then it must conform to the requirements of that Functionâs type.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently the arguments for the <a class="reference internal" href="#Function.UserDefinedFunction.function" title="Function.UserDefinedFunction.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a> of a UserDefinedFunction are NOT
assigned as attributes of the UserDefinedFunction object or its owner, nor to its <code class="xref std std-keyword docutils literal"><span class="pre">user_params</span></code> dict.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>function</strong> (<a class="reference internal" href="#Function.AccumulatorIntegrator.function" title="Function.AccumulatorIntegrator.function"><em>function</em></a>) â specifies function to âwrap.â It can be any function, take any arguments (including standard ones,
such as <code class="xref std std-keyword docutils literal"><span class="pre">params</span></code> and <code class="xref std std-keyword docutils literal"><span class="pre">context</span></code>) and return any value(s), so long as these are consistent
with the context in which the UserDefinedFunction will be used.</li>
<li><strong>variable</strong> (<em>value : default ClassDefaults.variable</em>) â specifies the format and a default value for the input to <a class="reference internal" href="#"><span class="doc">function</span></a>.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.UserDefinedFunction.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.UserDefinedFunction.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>value</em> â format and default value can be specified by the <code class="xref std std-keyword docutils literal"><span class="pre">variable</span></code> argument of the constructor;  otherwise,
they are specified by the Functionâs <code class="xref std std-keyword docutils literal"><span class="pre">ClassDefaults.variable</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.UserDefinedFunction.function">
<code class="descname">function</code><a class="headerlink" href="#Function.UserDefinedFunction.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>function</em> â called by the Functionâs <a class="reference internal" href="#Function.Function_Base.owner" title="Function.Function_Base.owner"><code class="xref any py py-attr docutils literal"><span class="pre">owner</span></code></a> when it is executed.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.UserDefinedFunction.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.UserDefinedFunction.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Mechanism</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.UserDefinedFunction.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.UserDefinedFunction.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.Reduce">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Reduce</code><span class="sig-paren">(</span><em>default_variable=ClassDefaults.variable</em>, <em>operation=SUM</em>, <em>scale=1.0</em>, <em>offset=0.0</em>, <em>params=None</em>, <em>owner=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Reduce" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="reduce">Combine values in each of one or more arrays into a single value for each array.
Use optional SCALE and OFFSET parameters to linearly transform the resulting value for each array.
Returns a scalar value for each array of the input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>default_variable</strong> (<em>list</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â specifies a template for the value to be transformed and its default value;  all entries must be numeric.</li>
<li><strong>operation</strong> (<em>SUM</em><em> or </em><em>PRODUCT : default SUM</em>) â specifies whether to sum or multiply the elements in <code class="xref any docutils literal"><span class="pre">variable</span></code> of
<a class="reference internal" href="#Function.Reduce.function" title="Function.Reduce.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>.</li>
<li><strong>scale</strong> (<em>float</em>) â specifies a value by which to multiply each element of the output of <a class="reference internal" href="#Function.Reduce.function" title="Function.Reduce.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>
(see <a class="reference internal" href="#Function.Reduce.scale" title="Function.Reduce.scale"><code class="xref any py py-attr docutils literal"><span class="pre">scale</span></code></a> for details)</li>
<li><strong>offset</strong> (<em>float</em>) â specifies a value to add to each element of the output of <a class="reference internal" href="#Function.Reduce.function" title="Function.Reduce.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>
(see <a class="reference internal" href="#Function.Reduce.offset" title="Function.Reduce.offset"><code class="xref any py py-attr docutils literal"><span class="pre">offset</span></code></a> for details)</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.Reduce.default_variable">
<code class="descname">default_variable</code><a class="headerlink" href="#Function.Reduce.default_variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>list or np.array</em> â contains array(s) to be reduced.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reduce.operation">
<code class="descname">operation</code><a class="headerlink" href="#Function.Reduce.operation" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>SUM or PRODUCT</em> â determines whether elements of each array in <code class="xref any docutils literal"><span class="pre">variable</span></code> of
<a class="reference internal" href="#Function.Reduce.function" title="Function.Reduce.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a> are summmed or multiplied.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reduce.scale">
<code class="descname">scale</code><a class="headerlink" href="#Function.Reduce.scale" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float</em> â value is applied multiplicatively to each element of the array after applying the <a class="reference internal" href="#Function.Reduce.operation" title="Function.Reduce.operation"><code class="xref any py py-attr docutils literal"><span class="pre">operation</span></code></a>
(see <a class="reference internal" href="#Function.Reduce.scale" title="Function.Reduce.scale"><code class="xref any py py-attr docutils literal"><span class="pre">scale</span></code></a> for details);  this done before applying the <a class="reference internal" href="#Function.Reduce.offset" title="Function.Reduce.offset"><code class="xref any py py-attr docutils literal"><span class="pre">offset</span></code></a>
(if it is specified).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reduce.offset">
<code class="descname">offset</code><a class="headerlink" href="#Function.Reduce.offset" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float</em> â value is added to each element of the array after applying the <a class="reference internal" href="#Function.Reduce.operation" title="Function.Reduce.operation"><code class="xref any py py-attr docutils literal"><span class="pre">operation</span></code></a>
and <a class="reference internal" href="#Function.Reduce.scale" title="Function.Reduce.scale"><code class="xref any py py-attr docutils literal"><span class="pre">scale</span></code></a> (if it is specified).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reduce.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.Reduce.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Mechanism</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reduce.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.Reduce.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.Reduce.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 2&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Reduce.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate sum or product of the elements for each array in <code class="xref any docutils literal"><span class="pre">variable</span></code>,
apply <a class="reference internal" href="#Function.Reduce.scale" title="Function.Reduce.scale"><code class="xref any py py-attr docutils literal"><span class="pre">scale</span></code></a> and/or <a class="reference internal" href="#Function.Reduce.offset" title="Function.Reduce.offset"><code class="xref any py py-attr docutils literal"><span class="pre">offset</span></code></a>, and return array of resulting values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>list</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â a list or np.array of numeric values.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) â specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Sum or product of arrays in variable</strong> â in an array that is one dimension less than <code class="xref any docutils literal"><span class="pre">variable</span></code>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">np.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.LinearCombination">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">LinearCombination</code><span class="sig-paren">(</span><em>default_variable</em>, <em>weights=None</em>, <em>exponents=None</em>, <em>operation=SUM</em>, <em>scale=None</em>, <em>offset=None</em>, <em>params=None</em>, <em>owner=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LinearCombination" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="linearcombination">Linearly combine arrays of values, with optional weighting and/or exponentiation of each array prior to combining,
and scaling and/or offset of result.</p>
<p>Combines the arrays in the items of the <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> argument.  Each array can be
individually weighted and/or exponentiated; they can combined additively or multiplicatively; and the resulting
array can be multiplicatively transformed and/or additively offset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>1d</em><em> or </em><em>2d np.array : default ClassDefaults.variable</em>) â specifies a template for the arrays to be combined.  If it is 2d, all items must have the same length.</li>
<li><strong>weights</strong> (<em>1d</em><em> or </em><em>2d np.array : default None</em>) â specifies values used to multiply the elements of each array in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.
If it is 1d, its length must equal the number of items in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>;
if it is 2d, the length of each item must be the same as those in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>,
and there must be the same number of items as there are in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>
(see <a class="reference internal" href="#Function.LinearCombination.weights" title="Function.LinearCombination.weights"><code class="xref any py py-attr docutils literal"><span class="pre">weights</span></code></a> for details)</li>
<li><strong>exponents</strong> (<em>1d</em><em> or </em><em>2d np.array : default None</em>) â specifies values used to exponentiate the elements of each array in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.
If it is 1d, its length must equal the number of items in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>;
if it is 2d, the length of each item must be the same as those in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>,
and there must be the same number of items as there are in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>
(see <a class="reference internal" href="#Function.LinearCombination.exponents" title="Function.LinearCombination.exponents"><code class="xref any py py-attr docutils literal"><span class="pre">exponents</span></code></a> for details)</li>
<li><strong>operation</strong> (<em>SUM</em><em> or </em><em>PRODUCT : default SUM</em>) â specifies whether the <a class="reference internal" href="#Function.LinearCombination.function" title="Function.LinearCombination.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a> takes the elementwise (Hadamarad)
sum or product of the arrays in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</li>
<li><strong>scale</strong> (<em>float</em><em> or </em><em>np.ndarray : default None</em>) â specifies a value by which to multiply each element of the result of <a class="reference internal" href="#Function.LinearCombination.function" title="Function.LinearCombination.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>
(see <a class="reference internal" href="#Function.LinearCombination.scale" title="Function.LinearCombination.scale"><code class="xref any py py-attr docutils literal"><span class="pre">scale</span></code></a> for details)</li>
<li><strong>offset</strong> (<em>float</em><em> or </em><em>np.ndarray : default None</em>) â specifies a value to add to each element of the result of <a class="reference internal" href="#Function.LinearCombination.function" title="Function.LinearCombination.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>
(see <a class="reference internal" href="#Function.LinearCombination.offset" title="Function.LinearCombination.offset"><code class="xref any py py-attr docutils literal"><span class="pre">offset</span></code></a> for details)</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.LinearCombination.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.LinearCombination.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d or 2d np.array</em> â contains the arrays to be combined by <a class="reference internal" href="#linearcombination"><span class="std std-ref">function</span></a>.  If it is 1d, the array is simply
linearly transformed by and <a class="reference internal" href="#Function.LinearCombination.scale" title="Function.LinearCombination.scale"><code class="xref any py py-attr docutils literal"><span class="pre">scale</span></code></a> and <a class="reference internal" href="#Function.LinearCombination.scale" title="Function.LinearCombination.scale"><code class="xref any py py-attr docutils literal"><span class="pre">offset</span></code></a>.
If it is 2d, the arrays (all of which must be of equal length) are weighted and/or exponentiated as
specified by <a class="reference internal" href="#Function.LinearCombination.weights" title="Function.LinearCombination.weights"><code class="xref any py py-attr docutils literal"><span class="pre">weights</span></code></a> and/or <a class="reference internal" href="#Function.LinearCombination.exponents" title="Function.LinearCombination.exponents"><code class="xref any py py-attr docutils literal"><span class="pre">exponents</span></code></a>
and then combined as specified by <a class="reference internal" href="#Function.LinearCombination.operation" title="Function.LinearCombination.operation"><code class="xref any py py-attr docutils literal"><span class="pre">operation</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.LinearCombination.weights">
<code class="descname">weights</code><a class="headerlink" href="#Function.LinearCombination.weights" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d or 2d np.array</em> â if it is 1d, each element is used to multiply all elements in the corresponding array of
<a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>;    if it is 2d, then each array is multiplied elementwise
(i.e., the Hadamard Product is taken) with the corresponding array of <code class="xref any docutils literal"><span class="pre">variable</span></code>.
All <code class="xref std std-keyword docutils literal"><span class="pre">weights</span></code> are applied before any exponentiation (if it is specified).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.LinearCombination.exponents">
<code class="descname">exponents</code><a class="headerlink" href="#Function.LinearCombination.exponents" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d or 2d np.array</em> â if it is 1d, each element is used to exponentiate the elements of the corresponding array of
<code class="xref any docutils literal"><span class="pre">variable</span></code>;  if it is 2d, the element of each array is used to exponentiate
the correspnding element of the corresponding array of <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.
In either case, exponentiating is applied after application of the <a class="reference internal" href="#Function.LinearCombination.weights" title="Function.LinearCombination.weights"><code class="xref any py py-attr docutils literal"><span class="pre">weights</span></code></a>
(if any are specified).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.LinearCombination.operation">
<code class="descname">operation</code><a class="headerlink" href="#Function.LinearCombination.operation" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>SUM or PRODUCT</em> â determines whether the <a class="reference internal" href="#Function.LinearCombination.function" title="Function.LinearCombination.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a> takes the elementwise (Hadamard) sum or
product of the arrays in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.LinearCombination.scale">
<code class="descname">scale</code><a class="headerlink" href="#Function.LinearCombination.scale" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float or np.ndarray</em> â value is applied multiplicatively to each element of the array after applying the
<a class="reference internal" href="#Function.LinearCombination.operation" title="Function.LinearCombination.operation"><code class="xref any py py-attr docutils literal"><span class="pre">operation</span></code></a> (see <a class="reference internal" href="#Function.LinearCombination.scale" title="Function.LinearCombination.scale"><code class="xref any py py-attr docutils literal"><span class="pre">scale</span></code></a> for details);
this done before applying the <a class="reference internal" href="#Function.LinearCombination.offset" title="Function.LinearCombination.offset"><code class="xref any py py-attr docutils literal"><span class="pre">offset</span></code></a> (if it is specified).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.LinearCombination.offset">
<code class="descname">offset</code><a class="headerlink" href="#Function.LinearCombination.offset" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float or np.ndarray</em> â value is added to each element of the array after applying the <a class="reference internal" href="#Function.LinearCombination.operation" title="Function.LinearCombination.operation"><code class="xref any py py-attr docutils literal"><span class="pre">operation</span></code></a>
and <a class="reference internal" href="#Function.LinearCombination.scale" title="Function.LinearCombination.scale"><code class="xref any py py-attr docutils literal"><span class="pre">scale</span></code></a> (if it is specified).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.LinearCombination.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.LinearCombination.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Mechanism</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.LinearCombination.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.LinearCombination.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.LinearCombination.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 2&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LinearCombination.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Apply <a class="reference internal" href="#Function.LinearCombination.weights" title="Function.LinearCombination.weights"><code class="xref any py py-attr docutils literal"><span class="pre">weights</span></code></a> and/or <code class="xref any docutils literal"><span class="pre">exponents</span></code> to the
arrays in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>, then take their sum or product (as specified by
<a class="reference internal" href="#Function.LinearCombination.operation" title="Function.LinearCombination.operation"><code class="xref any py py-attr docutils literal"><span class="pre">operation</span></code></a>), apply <a class="reference internal" href="#Function.LinearCombination.scale" title="Function.LinearCombination.scale"><code class="xref any py py-attr docutils literal"><span class="pre">scale</span></code></a> and/or <a class="reference internal" href="#Function.LinearCombination.offset" title="Function.LinearCombination.offset"><code class="xref any py py-attr docutils literal"><span class="pre">offset</span></code></a>, and return the resulting array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>1d</em><em> or </em><em>2d np.array : default ClassDefaults.variable</em>) â a single numeric array, or multiple arrays to be combined; if it is 2d, all arrays must have the same length.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) â specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>combined array</strong> â the result of linearly combining the arrays in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">1d np.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.TransferFunction">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">TransferFunction</code><span class="sig-paren">(</span><em>default_variable</em>, <em>params</em>, <em>owner</em>, <em>prefs</em>, <em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.TransferFunction" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Function that transforms variable but maintains its shape</p>
<p>All TransferFunctions must have the following attributes:</p>
<p><a class="reference internal" href="#Function.SoftMax.bounds" title="Function.SoftMax.bounds"><code class="xref any py py-attr docutils literal"><span class="pre">bounds</span></code></a> â specifies the lower and upper limits of the result;  if there are none, the attribute is set to
<code class="xref any docutils literal"><span class="pre">None</span></code>;  if it has at least one bound, the attribute is set to a tuple specifying the lower and upper bounds,
respectively, with <code class="xref any docutils literal"><span class="pre">None</span></code> as the entry for no bound.</p>
<p><code class="xref any docutils literal"><span class="pre">multiplicative_param</span></code> and <code class="xref any docutils literal"><span class="pre">additive_param</span></code> â each of these is assigned the name of one of the functionâs
parameters and used by <a class="reference internal" href="ModulatoryProjection.html"><span class="doc">ModulatoryProjections</span></a> to modulate the output of the
TransferFunctionâs function (see <a class="reference internal" href="#function-modulatory-params"><span class="std std-ref">Modulatory Parameters</span></a>).</p>
</dd></dl>

<dl class="class">
<dt id="Function.Linear">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Linear</code><span class="sig-paren">(</span><em>default_variable</em>, <em>slope=1.0</em>, <em>intercept=0.0</em>, <em>params=None</em>, <em>owner=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Linear" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="linear">Linearly transform variable.</p>
<p>Note: default values for <a class="reference internal" href="#Function.Linear.slope" title="Function.Linear.slope"><code class="xref any py py-attr docutils literal"><span class="pre">slope</span></code></a> and <a class="reference internal" href="#Function.Linear.intercept" title="Function.Linear.intercept"><code class="xref any py py-attr docutils literal"><span class="pre">intercept</span></code></a> implement the IDENTITY_FUNCTION</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>number</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â specifies a template for the value to be transformed.</li>
<li><strong>slope</strong> (<em>float : default 1.0</em>) â specifies a value by which to multiply <a class="reference internal" href="#Function.Linear.variable" title="Function.Linear.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</li>
<li><strong>intercept</strong> (<em>float : default 0.0</em>) â specifies a value to add to each element of <a class="reference internal" href="#Function.Linear.variable" title="Function.Linear.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> after applying <a class="reference internal" href="#Function.Linear.slope" title="Function.Linear.slope"><code class="xref any py py-attr docutils literal"><span class="pre">slope</span></code></a>.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.Linear.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.Linear.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>number or np.array</em> â contains value to be transformed.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Linear.slope">
<code class="descname">slope</code><a class="headerlink" href="#Function.Linear.slope" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float</em> â value by which each element of <a class="reference internal" href="#Function.Linear.variable" title="Function.Linear.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> is multiplied before applying the
<a class="reference internal" href="#Function.Linear.intercept" title="Function.Linear.intercept"><code class="xref any py py-attr docutils literal"><span class="pre">intercept</span></code></a> (if it is specified).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Linear.intercept">
<code class="descname">intercept</code><a class="headerlink" href="#Function.Linear.intercept" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float</em> â value added to each element of <a class="reference internal" href="#Function.Linear.variable" title="Function.Linear.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> after applying the <a class="reference internal" href="#Function.Linear.slope" title="Function.Linear.slope"><code class="xref any py py-attr docutils literal"><span class="pre">slope</span></code></a>
(if it is specified).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Linear.bounds">
<code class="descname">bounds</code><a class="headerlink" href="#Function.Linear.bounds" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>None</em></p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Linear.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.Linear.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Mechanism</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Linear.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.Linear.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.Linear.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 2&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Linear.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return: <a class="reference internal" href="#Function.Linear.slope" title="Function.Linear.slope"><code class="xref any py py-attr docutils literal"><span class="pre">slope</span></code></a> * <a class="reference internal" href="#Function.Linear.variable" title="Function.Linear.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> + <a class="reference internal" href="#Function.Linear.intercept" title="Function.Linear.intercept"><code class="xref any py py-attr docutils literal"><span class="pre">intercept</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>number</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â a single value or array to be transformed.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) â specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>linear transformation of variable</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">number or np.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Function.Linear.derivative">
<code class="descname">derivative</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Function.Linear.derivative" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Derivative of <a class="reference internal" href="#Function.Linear.function" title="Function.Linear.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>derivative</strong> â current value of <a class="reference internal" href="#Function.Linear.slope" title="Function.Linear.slope"><code class="xref any py py-attr docutils literal"><span class="pre">slope</span></code></a>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">number</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.Exponential">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Exponential</code><span class="sig-paren">(</span><em>default_variable</em>, <em>scale=1.0</em>, <em>rate=1.0</em>, <em>params=None</em>, <em>owner=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Exponential" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="exponential">Exponentially transform variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>number</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â specifies a template for the value to be transformed.</li>
<li><strong>rate</strong> (<em>float : default 1.0</em>) â specifies a value by which to multiply <a class="reference internal" href="#Function.Exponential.variable" title="Function.Exponential.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> before exponentiation.</li>
<li><strong>scale</strong> (<em>float : default 1.0</em>) â specifies a value by which to multiply the exponentiated value of <a class="reference internal" href="#Function.Exponential.variable" title="Function.Exponential.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.Exponential.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.Exponential.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>number or np.array</em> â contains value to be transformed.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Exponential.rate">
<code class="descname">rate</code><a class="headerlink" href="#Function.Exponential.rate" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float</em> â value by which <a class="reference internal" href="#Function.Exponential.variable" title="Function.Exponential.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> is multiplied before exponentiation.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Exponential.scale">
<code class="descname">scale</code><a class="headerlink" href="#Function.Exponential.scale" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float</em> â value by which the exponentiated value is multiplied.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Exponential.bounds">
<code class="descname">bounds</code><a class="headerlink" href="#Function.Exponential.bounds" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>(0, None)</em></p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Exponential.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.Exponential.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Mechanism</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Exponential.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.Exponential.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.Exponential.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 2&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Exponential.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return: <a class="reference internal" href="#Function.Exponential.scale" title="Function.Exponential.scale"><code class="xref any py py-attr docutils literal"><span class="pre">scale</span></code></a> * e**(<a class="reference internal" href="#Function.Exponential.rate" title="Function.Exponential.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> * <a class="reference internal" href="#Function.Linear.variable" title="Function.Linear.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>number</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â a single value or array to be exponentiated.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) â specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>exponential transformation of variable</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">number or np.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Function.Exponential.derivative">
<code class="descname">derivative</code><span class="sig-paren">(</span><em>input</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Exponential.derivative" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Derivative of <a class="reference internal" href="#Function.Exponential.function" title="Function.Exponential.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>derivative</strong> â <a class="reference internal" href="#Function.Exponential.rate" title="Function.Exponential.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> * input.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">number</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.Logistic">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Logistic</code><span class="sig-paren">(</span><em>default_variable</em>, <em>gain=1.0</em>, <em>bias=0.0</em>, <em>params=None</em>, <em>owner=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Logistic" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="logistic">Logistically transform variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>number</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â specifies a template for the value to be transformed.</li>
<li><strong>gain</strong> (<em>float : default 1.0</em>) â specifies a value by which to multiply <a class="reference internal" href="#Function.Linear.variable" title="Function.Linear.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> before logistic transformation</li>
<li><strong>bias</strong> (<em>float : default 0.0</em>) â specifies a value to add to each element of <a class="reference internal" href="#Function.Linear.variable" title="Function.Linear.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> after applying <code class="xref any docutils literal"><span class="pre">gain</span></code>
but before logistic transformation.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.Logistic.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.Logistic.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>number or np.array</em> â contains value to be transformed.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Logistic.gain">
<code class="descname">gain</code><a class="headerlink" href="#Function.Logistic.gain" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float</em> â value by which each element of <a class="reference internal" href="#Function.Logistic.variable" title="Function.Logistic.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> is multiplied before applying the
<code class="xref any docutils literal"><span class="pre">bias</span></code> (if it is specified).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Logistic.bias">
<code class="descname">bias</code><a class="headerlink" href="#Function.Logistic.bias" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float</em> â value added to each element of <a class="reference internal" href="#Function.Logistic.variable" title="Function.Logistic.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> after applying the <a class="reference internal" href="#Function.Logistic.gain" title="Function.Logistic.gain"><code class="xref any py py-attr docutils literal"><span class="pre">gain</span></code></a>
(if it is specified).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Logistic.bounds">
<code class="descname">bounds</code><a class="headerlink" href="#Function.Logistic.bounds" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>(0,1)</em></p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Logistic.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.Logistic.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Mechanism</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Logistic.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.Logistic.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.Logistic.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 2&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Logistic.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return: 1 / (1 + e**( (<a class="reference internal" href="#Function.Logistic.gain" title="Function.Logistic.gain"><code class="xref any py py-attr docutils literal"><span class="pre">gain</span></code></a> * <a class="reference internal" href="#Function.Logistic.variable" title="Function.Logistic.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>) + <a class="reference internal" href="#Function.Logistic.bias" title="Function.Logistic.bias"><code class="xref any py py-attr docutils literal"><span class="pre">bias</span></code></a>))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>number</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â a single value or array to be transformed.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) â specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>logistic transformation of variable</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">number or np.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Function.Logistic.derivative">
<code class="descname">derivative</code><span class="sig-paren">(</span><em>output</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Logistic.derivative" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Derivative of <a class="reference internal" href="#Function.Logistic.function" title="Function.Logistic.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>derivative</strong> â output * (1 - output).</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">number</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.SoftMax">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">SoftMax</code><span class="sig-paren">(</span><em>default_variable</em>, <em>gain=1.0</em>, <em>output=ALL</em>, <em>params=None</em>, <em>owner=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.SoftMax" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="softmax">SoftMax transform of variable (see <a class="reference external" href="http://eli.thegreenplace.net/2016/the-softmax-function-and-its-derivative/">The Softmax function and its derivative</a> for a nice discussion).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>default_variable</strong> (<em>1d np.array : default ClassDefaults.variable</em>) â specifies a template for the value to be transformed.</li>
<li><strong>gain</strong> (<em>float : default 1.0</em>) â specifies a value by which to multiply <a class="reference internal" href="#Function.Linear.variable" title="Function.Linear.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> before SoftMax transformation.</li>
<li><strong>output</strong> (<a class="reference internal" href="ControlSignal.html#ModulatorySignals.ControlSignal.ControlSignalCosts.ALL" title="ModulatorySignals.ControlSignal.ControlSignalCosts.ALL"><em>ALL</em></a><em>, </em><em>MAX_VAL</em><em>, </em><em>MAX_INDICATOR</em><em>, or </em><em>PROB : default ALL</em>) â specifies the format of array returned by <a class="reference internal" href="#Function.SoftMax.function" title="Function.SoftMax.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>
(see <a class="reference internal" href="#Function.SoftMax.output" title="Function.SoftMax.output"><code class="xref any py py-attr docutils literal"><span class="pre">output</span></code></a> for details).</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.SoftMax.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.SoftMax.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d np.array</em> â contains value to be transformed.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.SoftMax.gain">
<code class="descname">gain</code><a class="headerlink" href="#Function.SoftMax.gain" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float</em> â value by which <a class="reference internal" href="#Function.Logistic.variable" title="Function.Logistic.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> is multiplied before the SoftMax transformation;  determines
the âsharpnessâ of the distribution.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.SoftMax.output">
<code class="descname">output</code><a class="headerlink" href="#Function.SoftMax.output" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>ALL, MAX_VAL, MAX_INDICATOR, or PROB</em> â determines how the SoftMax-transformed values of the elements in <a class="reference internal" href="#Function.SoftMax.variable" title="Function.SoftMax.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> are reported
in the array returned by <code class="xref any docutils literal"><span class="pre">function</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><strong>ALL</strong>: array of all SoftMax-transformed values (the default);</li>
<li><strong>MAX_VAL</strong>: SoftMax-transformed value for the element with the maximum such value, 0 for all others;</li>
<li><strong>MAX_INDICATOR</strong>: 1 for the element with the maximum SoftMax-transformed value, 0 for all others;</li>
<li><strong>PROB</strong>: probabilistically chosen element based on SoftMax-transformed values after normalizing sum of
values to 1, 0 for all others.</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="Function.SoftMax.bounds">
<code class="descname">bounds</code><a class="headerlink" href="#Function.SoftMax.bounds" title="Permalink to this definition">Â¶</a></dt>
<dd><p>None if <a class="reference internal" href="#Function.SoftMax.output" title="Function.SoftMax.output"><code class="xref any py py-attr docutils literal"><span class="pre">output</span></code></a> == MAX_VAL, else (0,1) : default (0,1)</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.SoftMax.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.SoftMax.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Mechanism</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.SoftMax.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.SoftMax.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.SoftMax.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 2&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.SoftMax.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return: e**(<a class="reference internal" href="#Function.SoftMax.gain" title="Function.SoftMax.gain"><code class="xref any py py-attr docutils literal"><span class="pre">gain</span></code></a> * <a class="reference internal" href="#Function.SoftMax.variable" title="Function.SoftMax.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>) /
sum(e**(<a class="reference internal" href="#Function.SoftMax.gain" title="Function.SoftMax.gain"><code class="xref any py py-attr docutils literal"><span class="pre">gain</span></code></a> * <a class="reference internal" href="#Function.SoftMax.variable" title="Function.SoftMax.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>)),
filtered by <a class="reference internal" href="#Function.SoftMax.output" title="Function.SoftMax.output"><code class="xref any py py-attr docutils literal"><span class="pre">ouptput</span></code></a> specification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>1d np.array : default ClassDefaults.variable</em>) â an array to be transformed.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) â specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>SoftMax transformation of variable</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">number or np.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Function.SoftMax.derivative">
<code class="descname">derivative</code><span class="sig-paren">(</span><em>output</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.SoftMax.derivative" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate the derivative of <a class="reference internal" href="#Function.SoftMax.function" title="Function.SoftMax.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>.  If OUTPUT_TYPE for the SoftMax Function is ALL,
return Jacobian matrix (derivative for each element of the output array with respect to each of the others):</p>
<blockquote>
<div>D<sub>j</sub>S<sub>i</sub> = S<sub>i</sub>(ð¹<sub>i,j</sub> - S<sub>j</sub>),
where ð¹<sub>i,j</sub>=1 if i=j and ð¹<sub>i,j</sub>=0 if iâ j.</div></blockquote>
<p>If OUTPUT_TYPE is MAX_VAL or MAX_INDICATOR, return 1d array of the derivatives of the maximum
value with respect to the others (calculated as above). If OUTPUT_TYPE is PROB, raise an exception
(since it is ambiguous as to which element would have been chosen by the SoftMax function)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>derivative</strong> â derivative of values returns by SoftMax.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">1d or 2d np.array (depending on OUTPUT_TYPE of SoftMax)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.LinearMatrix">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">LinearMatrix</code><span class="sig-paren">(</span><em>default_variable</em>, <em>matrix=None</em>, <em>params=None</em>, <em>owner=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LinearMatrix" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="linearmatrix">Matrix transform of variable:</p>
<blockquote>
<div><a class="reference internal" href="#Function.LinearMatrix.function" title="Function.LinearMatrix.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a> returns dot product of <a class="reference internal" href="#Function.LinearMatrix.variable" title="Function.LinearMatrix.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> and
<a class="reference internal" href="#Function.LinearMatrix.matrix" title="Function.LinearMatrix.matrix"><code class="xref any py py-attr docutils literal"><span class="pre">matrix</span></code></a>.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>list</em><em> or </em><em>1d np.array : default ClassDefaults.variable</em>) â specifies a template for the value to be transformed; length must equal the number of rows of <a class="reference internal" href="#Function.LinearMatrix.matrix" title="Function.LinearMatrix.matrix"><code class="xref any py py-attr docutils literal"><span class="pre">matrix</span></code></a>.</li>
<li><strong>matrix</strong> (<em>number</em><em>, </em><em>list</em><em>, </em><em>1d</em><em> or </em><em>2d np.ndarray</em><em>, </em><em>np.matrix</em><em>, </em><a class="reference internal" href="#Function.AccumulatorIntegrator.function" title="Function.AccumulatorIntegrator.function"><em>function</em></a><em>, or </em><em>matrix keyword : default IDENTITY_MATRIX</em>) â specifies matrix used to transform <a class="reference internal" href="#Function.LinearMatrix.variable" title="Function.LinearMatrix.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>
(see <a class="reference internal" href="#Function.LinearMatrix.matrix" title="Function.LinearMatrix.matrix"><code class="xref any py py-attr docutils literal"><span class="pre">matrix</span></code></a> for specification details).</li>
<li><strong>bounds</strong> (<em>None</em>) â </li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.LinearMatrix.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.LinearMatrix.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d np.array</em> â contains value to be transformed.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.LinearMatrix.matrix">
<code class="descname">matrix</code><a class="headerlink" href="#Function.LinearMatrix.matrix" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>2d np.array</em> â matrix used to transform <a class="reference internal" href="#Function.LinearMatrix.variable" title="Function.LinearMatrix.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.
Can be specified as any of the following:</p>
<blockquote>
<div><ul class="simple">
<li>number - used as the filler value for all elements of the <code class="xref std std-keyword docutils literal"><span class="pre">matrix</span></code> (call to np.fill);</li>
<li>list of arrays, 2d np.array or np.matrix - assigned as the value of <code class="xref std std-keyword docutils literal"><span class="pre">matrix</span></code>;</li>
<li>matrix keyword - see <a class="reference internal" href="Keywords.html#Keywords.MatrixKeywords" title="Keywords.MatrixKeywords"><code class="xref any py py-class docutils literal"><span class="pre">MatrixKeywords</span></code></a> for list of options.</li>
</ul>
</div></blockquote>
<p>Rows correspond to elements of the input array (outer index), and
columns correspond to elements of the output array (inner index).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.LinearMatrix.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.LinearMatrix.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Mechanism</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.LinearMatrix.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.LinearMatrix.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.LinearMatrix.instantiate_matrix">
<code class="descname">instantiate_matrix</code><span class="sig-paren">(</span><em>specification</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LinearMatrix.instantiate_matrix" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Implements matrix indicated by specification</p>
<blockquote>
<div><p>Specification is derived from MATRIX param (passed to self.__init__ or self.function)</p>
<dl class="docutils">
<dt>Specification (validated in _validate_params):</dt>
<dd><ul class="first last simple">
<li>single number (used to fill self.matrix)</li>
<li>matrix keyword (see get_matrix)</li>
<li>2D list or np.ndarray of numbers</li>
</ul>
</dd>
</dl>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return matrix:</th><td class="field-body">(2D list)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Function.LinearMatrix.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 2&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LinearMatrix.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return: <a class="reference internal" href="#Function.LinearMatrix.variable" title="Function.LinearMatrix.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> â¢ <a class="reference internal" href="#Function.LinearMatrix.matrix" title="Function.LinearMatrix.matrix"><code class="xref any py py-attr docutils literal"><span class="pre">matrix</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>list</em><em> or </em><em>1d np.array</em>) â array to be transformed;  length must equal the number of rows of âmatrix &lt;LinearMatrix.matrix&gt;`.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) â specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dot product of variable and matrix</strong> â length of the array returned equals the number of columns of <a class="reference internal" href="#Function.LinearMatrix.matrix" title="Function.LinearMatrix.matrix"><code class="xref any py py-attr docutils literal"><span class="pre">matrix</span></code></a>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">1d np.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.Integrator">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Integrator</code><span class="sig-paren">(</span><em>default_variable=None, rate: &lt;function parameter_spec at 0x1055bb1e0&gt; = 1.0, noise=0.0, initializer=[[0]], params: &lt;typecheck.framework.optional object at 0x10753e668&gt; = None, owner=None, prefs: &lt;function is_pref_set at 0x1055bcd90&gt; = None, context='Integrator Init'</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Integrator" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="docutils">
<dt>Integrator(                         default_variable=None,          rate=1.0,</dt>
<dd>noise=0.0,                      time_step_size=1.0,             initializer,             params=None,                    owner=None,                     prefs=None,                     )</dd>
</dl>
<p id="integrator">Integrate current value of <a class="reference internal" href="#Function.Integrator.variable" title="Function.Integrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> with its prior value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>default_variable</strong> (<em>number</em><em>, </em><em>list</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â specifies a template for the value to be integrated;  if it is a list or array, each element is independently
integrated.</li>
<li><strong>rate</strong> (<em>float</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 1.0</em>) â specifies the rate of integration.  If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">variable</span></code> (see <a class="reference internal" href="#Function.Integrator.rate" title="Function.Integrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> for details).</li>
<li><strong>noise</strong> (<em>float</em><em>, </em><em>PsyNeuLink Function</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 0.0</em>) â specifies random value to be added in each call to <code class="xref any docutils literal"><span class="pre">function</span></code>. (see
<a class="reference internal" href="#Function.Integrator.noise" title="Function.Integrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a> for details).</li>
<li><strong>time_step_size</strong> (<em>float : default 0.0</em>) â determines the timing precision of the integration process when <a class="reference internal" href="#Function.Integrator.integration_type" title="Function.Integrator.integration_type"><code class="xref any py py-attr docutils literal"><span class="pre">integration_type</span></code></a>
is set to DIFFUSION (see <code class="xref any docutils literal"><span class="pre">time_step_size</span></code> for details.</li>
<li><strong>float</strong><strong>, </strong><strong>list</strong><strong> or </strong><strong>1d np.array</strong> (<a class="reference internal" href="#Function.Integrator.initializer" title="Function.Integrator.initializer"><em>initializer</em></a>) â specifies starting value for integration.  If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">default_variable</span></code> (see <a class="reference internal" href="#Function.Integrator.initializer" title="Function.Integrator.initializer"><code class="xref any py py-attr docutils literal"><span class="pre">initializer</span></code></a> for details).</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.Integrator.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.Integrator.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>number or np.array</em> â current input value some portion of which (determined by <a class="reference internal" href="#Function.Integrator.rate" title="Function.Integrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a>) that will be
added to the prior value;  if it is an array, each element is independently integrated.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Integrator.integration_type">
<code class="descname">integration_type</code><a class="headerlink" href="#Function.Integrator.integration_type" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>[**NEEDS TO BE SPECIFIED*</em>] : default [<strong>NEEDS TO BE SPECIFIED</strong>]* â [<strong>NEEDS TO BE SPECIFIED</strong>]</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Integrator.rate">
<code class="descname">rate</code><a class="headerlink" href="#Function.Integrator.rate" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float or 1d np.array</em> â determines the rate of integration based on current and prior values.  If integration_type is set to ADAPTIVE,
all elements must be between 0 and 1 (0 = no change; 1 = instantaneous change). If it has a single element, it
applies to all elements of <a class="reference internal" href="#Function.Integrator.variable" title="Function.Integrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>;  if it has more than one element, each element
applies to the corresponding element of <a class="reference internal" href="#Function.Integrator.variable" title="Function.Integrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Integrator.noise">
<code class="descname">noise</code><a class="headerlink" href="#Function.Integrator.noise" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float, function, list, or 1d np.array</em> â specifies random value to be added in each call to <code class="xref any docutils literal"><span class="pre">function</span></code>.</p>
<p>If noise is a list or array, it must be the same length as <code class="xref any docutils literal"><span class="pre">variable</span></code>. If noise is
specified as a single float or function, while <a class="reference internal" href="#Function.Integrator.variable" title="Function.Integrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> is a list or array,
noise will be applied to each variable element. In the case of a noise function, this means that the function
will be executed separately for each variable element.</p>
<p>Note that in the case of DIFFUSION, noise must be specified as a float (or list or array of floats) because this
value will be used to construct the standard DDM probability distribution. For all other types of integration,
in order to generate random noise, we recommend that you instead select a probability distribution function
(see <code class="xref any docutils literal"><span class="pre">Distribution</span> <span class="pre">Functions</span></code> for details), which will generate a new noise value from
its distribution on each execution. If noise is specified as a float or as a function with a fixed output (or a
list or array of these), then the noise will simply be an offset that remains the same across all executions.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Integrator.initializer">
<code class="descname">initializer</code><a class="headerlink" href="#Function.Integrator.initializer" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d np.array or list</em> â determines the starting value for integration (i.e., the value to which
<a class="reference internal" href="#Function.Integrator.previous_value" title="Function.Integrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a> is set.</p>
<p>If initializer is a list or array, it must be the same length as <code class="xref any docutils literal"><span class="pre">variable</span></code>. If
initializer is specified as a single float or function, while <a class="reference internal" href="#Function.Integrator.variable" title="Function.Integrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> is a list or
array, initializer will be applied to each variable element. In the case of an initializer function, this means
that the function will be executed separately for each variable element.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Integrator.previous_value">
<code class="descname">previous_value</code><a class="headerlink" href="#Function.Integrator.previous_value" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d np.array : default ClassDefaults.variable</em> â stores previous value with which <a class="reference internal" href="#Function.Integrator.variable" title="Function.Integrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> is integrated.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Integrator.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.Integrator.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Mechanism</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Integrator.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.Integrator.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.SimpleIntegrator">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">SimpleIntegrator</code><span class="sig-paren">(</span><em>default_variable=None</em>, <em>rate=1.0</em>, <em>noise=0.0</em>, <em>initializer</em>, <em>params=None</em>, <em>owner=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.SimpleIntegrator" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="simpleintegrator">Integrate current value of <a class="reference internal" href="#Function.SimpleIntegrator.variable" title="Function.SimpleIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> with its prior value:</p>
<p><code class="xref any docutils literal"><span class="pre">previous_value</span></code> +     <a class="reference internal" href="#Function.SimpleIntegrator.rate" title="Function.SimpleIntegrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> <a href="#id1"><span class="problematic" id="id2">*</span></a><code class="xref any docutils literal"><span class="pre">variable</span></code> +     <a class="reference internal" href="#Function.SimpleIntegrator.noise" title="Function.SimpleIntegrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a>;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>default_variable</strong> (<em>number</em><em>, </em><em>list</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â specifies a template for the value to be integrated;  if it is a list or array, each element is independently
integrated.</li>
<li><strong>rate</strong> (<em>float</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 1.0</em>) â specifies the rate of integration.  If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">variable</span></code> (see <a class="reference internal" href="#Function.SimpleIntegrator.rate" title="Function.SimpleIntegrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> for details).</li>
<li><strong>noise</strong> (<em>float</em><em>, </em><em>PsyNeuLink Function</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 0.0</em>) â specifies random value to be added in each call to <a class="reference internal" href="#Function.SimpleIntegrator.function" title="Function.SimpleIntegrator.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>. (see
<a class="reference internal" href="#Function.SimpleIntegrator.noise" title="Function.SimpleIntegrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a> for details).</li>
<li><strong>float</strong><strong>, </strong><strong>list</strong><strong> or </strong><strong>1d np.array</strong> (<a class="reference internal" href="#Function.Integrator.initializer" title="Function.Integrator.initializer"><em>initializer</em></a>) â specifies starting value for integration.  If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">default_variable</span></code> (see <code class="xref any docutils literal"><span class="pre">initializer</span></code> for details).</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.SimpleIntegrator.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.SimpleIntegrator.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>number or np.array</em> â current input value some portion of which (determined by <a class="reference internal" href="#Function.SimpleIntegrator.rate" title="Function.SimpleIntegrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a>) will be
added to the prior value;  if it is an array, each element is independently integrated.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.SimpleIntegrator.rate">
<code class="descname">rate</code><a class="headerlink" href="#Function.SimpleIntegrator.rate" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float or 1d np.array</em> â determines the rate of integration based on current and prior values. If it has a single element, it
applies to all elements of <a class="reference internal" href="#Function.SimpleIntegrator.variable" title="Function.SimpleIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>;  if it has more than one element, each element
applies to the corresponding element of <a class="reference internal" href="#Function.SimpleIntegrator.variable" title="Function.SimpleIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.SimpleIntegrator.noise">
<code class="descname">noise</code><a class="headerlink" href="#Function.SimpleIntegrator.noise" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float, function, list, or 1d np.array</em> â specifies random value to be added in each call to <a class="reference internal" href="#Function.SimpleIntegrator.function" title="Function.SimpleIntegrator.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>.</p>
<p>If noise is a list or array, it must be the same length as <code class="xref any docutils literal"><span class="pre">variable</span></code>.</p>
<p>If noise is specified as a single float or function, while <a class="reference internal" href="#Function.SimpleIntegrator.variable" title="Function.SimpleIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> is a list or array,
noise will be applied to each variable element. In the case of a noise function, this means that the function
will be executed separately for each variable element.</p>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In order to generate random noise, we recommend selecting a probability distribution function
(see <code class="xref any docutils literal"><span class="pre">Distribution</span> <span class="pre">Functions</span></code> for details), which will generate a new noise value from
its distribution on each execution. If noise is specified as a float or as a function with a fixed output, then
the noise will simply be an offset that remains the same across all executions.</p>
</div>
</div></blockquote>
</dd></dl>

<dl class="docutils">
<dt>initializer <span class="classifier-delimiter">:</span> <span class="classifier">float, 1d np.array or list</span></dt>
<dd><p class="first">determines the starting value for integration (i.e., the value to which
<code class="xref any docutils literal"><span class="pre">previous_value</span></code> is set.</p>
<p class="last">If initializer is a list or array, it must be the same length as <code class="xref any docutils literal"><span class="pre">variable</span></code>.</p>
</dd>
<dt>previous_value <span class="classifier-delimiter">:</span> <span class="classifier">1d np.array</span> <span class="classifier-delimiter">:</span> <span class="classifier">default ClassDefaults.variable</span></dt>
<dd>stores previous value with which <a class="reference internal" href="#Function.SimpleIntegrator.variable" title="Function.SimpleIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> is integrated.</dd>
<dt>owner <span class="classifier-delimiter">:</span> <span class="classifier">Mechanism</span></dt>
<dd><a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which the Function has been assigned.</dd>
<dt>prefs <span class="classifier-delimiter">:</span> <span class="classifier">PreferenceSet or specification dict</span> <span class="classifier-delimiter">:</span> <span class="classifier">Projection.classPreferences</span></dt>
<dd>the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</dd>
</dl>
<dl class="method">
<dt id="Function.SimpleIntegrator.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 2&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.SimpleIntegrator.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return: <a class="reference internal" href="#Function.Linear.slope" title="Function.Linear.slope"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> combined with <code class="xref any docutils literal"><span class="pre">previous_value</span></code>
according to <code class="xref any docutils literal"><span class="pre">previous_value</span></code> + <a class="reference internal" href="#Function.SimpleIntegrator.rate" title="Function.SimpleIntegrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> <a href="#id3"><span class="problematic" id="id4">*</span></a><code class="xref any docutils literal"><span class="pre">variable</span></code> + <a class="reference internal" href="#Function.SimpleIntegrator.noise" title="Function.SimpleIntegrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a>;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>number</em><em>, </em><em>list</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â a single value or array of values to be integrated.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>updated value of integral</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2d np.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.ConstantIntegrator">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">ConstantIntegrator</code><span class="sig-paren">(</span><em>default_variable=None</em>, <em>rate=1.0</em>, <em>noise=0.0</em>, <em>scale: parameter_spec = 1.0</em>, <em>offset: parameter_spec = 0.0</em>, <em>initializer</em>, <em>params=None</em>, <em>owner=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.ConstantIntegrator" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="constantintegrator">Integrates prior value by adding <a class="reference internal" href="#Function.Integrator.rate" title="Function.Integrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> and <a class="reference internal" href="#Function.Integrator.noise" title="Function.Integrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a>. (Ignores
<a class="reference internal" href="#Function.Integrator.variable" title="Function.Integrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>).</p>
<p><a class="reference internal" href="#Function.ConstantIntegrator.previous_value" title="Function.ConstantIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a> + <a class="reference internal" href="#Function.ConstantIntegrator.rate" title="Function.ConstantIntegrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> +
<a class="reference internal" href="#Function.ConstantIntegrator.noise" title="Function.ConstantIntegrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>default_variable</strong> (<em>number</em><em>, </em><em>list</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â specifies a template for the value to be integrated;  if it is a list or array, each element is independently
integrated.</li>
<li><strong>rate</strong> (<em>float</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 1.0</em>) â specifies the rate of integration.  If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">variable</span></code> (see <a class="reference internal" href="#Function.ConstantIntegrator.rate" title="Function.ConstantIntegrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> for details).</li>
<li><strong>noise</strong> (<em>float</em><em>, </em><em>PsyNeuLink Function</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 0.0</em>) â specifies random value to be added in each call to <a class="reference internal" href="#Function.ConstantIntegrator.function" title="Function.ConstantIntegrator.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>. (see
<a class="reference internal" href="#Function.ConstantIntegrator.noise" title="Function.ConstantIntegrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a> for details).</li>
<li><strong>float</strong><strong>, </strong><strong>list</strong><strong> or </strong><strong>1d np.array</strong> (<a class="reference internal" href="#Function.Integrator.initializer" title="Function.Integrator.initializer"><em>initializer</em></a>) â specifies starting value for integration.  If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">default_variable</span></code> (see <a class="reference internal" href="#Function.ConstantIntegrator.initializer" title="Function.ConstantIntegrator.initializer"><code class="xref any py py-attr docutils literal"><span class="pre">initializer</span></code></a> for details).</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.ConstantIntegrator.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.ConstantIntegrator.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>number or np.array</em> â</p>
<dl class="docutils">
<dt><strong>Ignored</strong> by the ConstantIntegrator function. Refer to SimpleIntegrator or AdaptiveIntegrator for integrator</dt>
<dd>functions that depend on both a prior value and a new value (variable).</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="Function.ConstantIntegrator.rate">
<code class="descname">rate</code><a class="headerlink" href="#Function.ConstantIntegrator.rate" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float or 1d np.array</em> â determines the rate of integration.</p>
<p>If it has a single element, that element is added to each element of
<a class="reference internal" href="#Function.ConstantIntegrator.previous_value" title="Function.ConstantIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a>.</p>
<p>If it has more than one element, each element is added to the corresponding element of
<a class="reference internal" href="#Function.ConstantIntegrator.previous_value" title="Function.ConstantIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.ConstantIntegrator.noise">
<code class="descname">noise</code><a class="headerlink" href="#Function.ConstantIntegrator.noise" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float, function, list, or 1d np.array</em> â specifies random value to be added in each call to <a class="reference internal" href="#Function.ConstantIntegrator.function" title="Function.ConstantIntegrator.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>.</p>
<p>If noise is a list or array, it must be the same length as <code class="xref any docutils literal"><span class="pre">variable</span></code>.</p>
<p>If noise is specified as a single float or function, while <a class="reference internal" href="#Function.ConstantIntegrator.variable" title="Function.ConstantIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> is a list or array,
noise will be applied to each variable element. In the case of a noise function, this means that the function
will be executed separately for each variable element.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In order to generate random noise, we recommend selecting a probability distribution function
(see <code class="xref any docutils literal"><span class="pre">Distribution</span> <span class="pre">Functions</span></code> for details), which will generate a new noise value from
its distribution on each execution. If noise is specified as a float or as a function with a fixed output, then
the noise will simply be an offset that remains the same across all executions.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="Function.ConstantIntegrator.initializer">
<code class="descname">initializer</code><a class="headerlink" href="#Function.ConstantIntegrator.initializer" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float, 1d np.array or list</em> â determines the starting value for integration (i.e., the value to which
<a class="reference internal" href="#Function.ConstantIntegrator.previous_value" title="Function.ConstantIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a> is set.</p>
<p>If initializer is a list or array, it must be the same length as <code class="xref any docutils literal"><span class="pre">variable</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.ConstantIntegrator.previous_value">
<code class="descname">previous_value</code><a class="headerlink" href="#Function.ConstantIntegrator.previous_value" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d np.array : default ClassDefaults.variable</em> â stores previous value to which <a class="reference internal" href="#Function.ConstantIntegrator.rate" title="Function.ConstantIntegrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> and <a class="reference internal" href="#Function.ConstantIntegrator.noise" title="Function.ConstantIntegrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a> will be
added.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.ConstantIntegrator.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.ConstantIntegrator.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Mechanism</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.ConstantIntegrator.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.ConstantIntegrator.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.ConstantIntegrator.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 2&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.ConstantIntegrator.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return: the sum of <a class="reference internal" href="#Function.ConstantIntegrator.previous_value" title="Function.ConstantIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a>, <a class="reference internal" href="#Function.ConstantIntegrator.rate" title="Function.ConstantIntegrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a>, and
<a class="reference internal" href="#Function.ConstantIntegrator.noise" title="Function.ConstantIntegrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) â specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>updated value of integral</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2d np.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.AdaptiveIntegrator">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">AdaptiveIntegrator</code><span class="sig-paren">(</span><em>default_variable=None</em>, <em>rate=1.0</em>, <em>noise=0.0</em>, <em>scale: parameter_spec = 1.0</em>, <em>offset: parameter_spec = 0.0</em>, <em>initializer</em>, <em>params=None</em>, <em>owner=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.AdaptiveIntegrator" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="adaptiveintegrator">Computes an exponentially weighted moving average.</p>
<p>(1 - <a class="reference internal" href="#Function.AdaptiveIntegrator.rate" title="Function.AdaptiveIntegrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a>) * <a class="reference internal" href="#Function.AdaptiveIntegrator.previous_value" title="Function.AdaptiveIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a> + <a class="reference internal" href="#Function.AdaptiveIntegrator.rate" title="Function.AdaptiveIntegrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> *
<a class="reference internal" href="#Function.AdaptiveIntegrator.variable" title="Function.AdaptiveIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> + <a class="reference internal" href="#Function.AdaptiveIntegrator.noise" title="Function.AdaptiveIntegrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>default_variable</strong> (<em>number</em><em>, </em><em>list</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â specifies a template for the value to be integrated;  if it is a list or array, each element is independently
integrated.</li>
<li><strong>rate</strong> (<em>float</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 1.0</em>) â specifies the smoothing factor of the EWMA.  If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">variable</span></code> (see <a class="reference internal" href="#Function.AdaptiveIntegrator.rate" title="Function.AdaptiveIntegrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> for details).</li>
<li><strong>noise</strong> (<em>float</em><em>, </em><em>PsyNeuLink Function</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 0.0</em>) â specifies random value to be added in each call to <a class="reference internal" href="#Function.AdaptiveIntegrator.function" title="Function.AdaptiveIntegrator.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>. (see
<a class="reference internal" href="#Function.AdaptiveIntegrator.noise" title="Function.AdaptiveIntegrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a> for details).</li>
<li><strong>float</strong><strong>, </strong><strong>list</strong><strong> or </strong><strong>1d np.array</strong> (<a class="reference internal" href="#Function.Integrator.initializer" title="Function.Integrator.initializer"><em>initializer</em></a>) â specifies starting value for integration.  If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">default_variable</span></code> (see <a class="reference internal" href="#Function.AdaptiveIntegrator.initializer" title="Function.AdaptiveIntegrator.initializer"><code class="xref any py py-attr docutils literal"><span class="pre">initializer</span></code></a> for details).</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.AdaptiveIntegrator.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.AdaptiveIntegrator.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>number or np.array</em> â current input value some portion of which (determined by <a class="reference internal" href="#Function.AdaptiveIntegrator.rate" title="Function.AdaptiveIntegrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a>) will be
added to the prior value;  if it is an array, each element is independently integrated.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AdaptiveIntegrator.rate">
<code class="descname">rate</code><a class="headerlink" href="#Function.AdaptiveIntegrator.rate" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float or 1d np.array</em> â determines the smoothing factor of the EWMA. All rate elements must be between 0 and 1 (rate = 0 â&gt; no change,
<code class="xref any docutils literal"><span class="pre">variable</span></code> is ignored; rate = 1 â&gt;
<a class="reference internal" href="#Function.AdaptiveIntegrator.previous_value" title="Function.AdaptiveIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a> is ignored).</p>
<p>If rate is a float, it is applied to all elements of <code class="xref any docutils literal"><span class="pre">variable</span></code> (and
<a class="reference internal" href="#Function.AdaptiveIntegrator.previous_value" title="Function.AdaptiveIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a>); if it has more than one element, each element is applied
to the corresponding element of <code class="xref any docutils literal"><span class="pre">variable</span></code> (and
<a class="reference internal" href="#Function.AdaptiveIntegrator.previous_value" title="Function.AdaptiveIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AdaptiveIntegrator.noise">
<code class="descname">noise</code><a class="headerlink" href="#Function.AdaptiveIntegrator.noise" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float, function, list, or 1d np.array</em> â specifies random value to be added in each call to <a class="reference internal" href="#Function.AdaptiveIntegrator.function" title="Function.AdaptiveIntegrator.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>.</p>
<p>If noise is a list or array, it must be the same length as <code class="xref any docutils literal"><span class="pre">variable</span></code>.</p>
<p>If noise is specified as a single float or function, while <a class="reference internal" href="#Function.AdaptiveIntegrator.variable" title="Function.AdaptiveIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> is a list or array,
noise will be applied to each variable element. In the case of a noise function, this means that the function
will be executed separately for each variable element.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In order to generate random noise, we recommend selecting a probability distribution function
(see <code class="xref any docutils literal"><span class="pre">Distribution</span> <span class="pre">Functions</span></code> for details), which will generate a new noise value from
its distribution on each execution. If noise is specified as a float or as a function with a fixed output, then
the noise will simply be an offset that remains the same across all executions.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="Function.AdaptiveIntegrator.initializer">
<code class="descname">initializer</code><a class="headerlink" href="#Function.AdaptiveIntegrator.initializer" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float, 1d np.array or list</em> â determines the starting value for time-averaging (i.e., the value to which
<a class="reference internal" href="#Function.AdaptiveIntegrator.previous_value" title="Function.AdaptiveIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a> is originally set).</p>
<p>If initializer is a list or array, it must be the same length as <code class="xref any docutils literal"><span class="pre">variable</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AdaptiveIntegrator.previous_value">
<code class="descname">previous_value</code><a class="headerlink" href="#Function.AdaptiveIntegrator.previous_value" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d np.array : default ClassDefaults.variable</em> â stores previous value with which <a class="reference internal" href="#Function.AdaptiveIntegrator.variable" title="Function.AdaptiveIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> is integrated.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AdaptiveIntegrator.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.AdaptiveIntegrator.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Mechanism</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AdaptiveIntegrator.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.AdaptiveIntegrator.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.AdaptiveIntegrator.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 2&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.AdaptiveIntegrator.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return: some fraction of <a class="reference internal" href="#Function.AdaptiveIntegrator.variable" title="Function.AdaptiveIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> combined with some fraction of <a class="reference internal" href="#Function.AdaptiveIntegrator.previous_value" title="Function.AdaptiveIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>number</em><em>, </em><em>list</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â a single value or array of values to be integrated.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) â specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>updated value of integral</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2d np.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.DriftDiffusionIntegrator">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">DriftDiffusionIntegrator</code><span class="sig-paren">(</span><em>default_variable=None</em>, <em>rate=1.0</em>, <em>noise=0.0</em>, <em>scale: parameter_spec = 1.0</em>, <em>offset: parameter_spec = 0.0</em>, <em>time_step_size=1.0</em>, <em>t0=0.0</em>, <em>decay=0.0</em>, <em>initializer</em>, <em>params=None</em>, <em>owner=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.DriftDiffusionIntegrator" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="driftdiffusionintegrator">Accumulate evidence overtime based on a stimulus, previous position, and noise.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>default_variable</strong> (<em>number</em><em>, </em><em>list</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â specifies a template for the value to be integrated;  if it is a list or array, each element is independently
integrated.</li>
<li><strong>rate</strong> (<em>float</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 1.0</em>) â specifies the rate of integration.  If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">variable</span></code> (see <a class="reference internal" href="#Function.DriftDiffusionIntegrator.rate" title="Function.DriftDiffusionIntegrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> for details).</li>
<li><strong>noise</strong> (<em>float</em><em>, </em><em>PsyNeuLink Function</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 0.0</em>) â specifies random value to be added in each call to <a class="reference internal" href="#Function.DriftDiffusionIntegrator.function" title="Function.DriftDiffusionIntegrator.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>. (see
<a class="reference internal" href="#Function.DriftDiffusionIntegrator.noise" title="Function.DriftDiffusionIntegrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a> for details).</li>
<li><strong>time_step_size</strong> (<em>float : default 0.0</em>) â determines the timing precision of the integration process (see <a class="reference internal" href="#Function.DriftDiffusionIntegrator.time_step_size" title="Function.DriftDiffusionIntegrator.time_step_size"><code class="xref any py py-attr docutils literal"><span class="pre">time_step_size</span></code></a> for details.</li>
<li><strong>t0</strong> (<em>float</em>) â determines the start time of the integration process and is used to compute the RESPONSE_TIME output state of
the DDM Mechanism.</li>
<li><strong>float</strong><strong>, </strong><strong>list</strong><strong> or </strong><strong>1d np.array</strong> (<a class="reference internal" href="#Function.Integrator.initializer" title="Function.Integrator.initializer"><em>initializer</em></a>) â specifies starting value for integration.  If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">default_variable</span></code> (see <a class="reference internal" href="#Function.DriftDiffusionIntegrator.initializer" title="Function.DriftDiffusionIntegrator.initializer"><code class="xref any py py-attr docutils literal"><span class="pre">initializer</span></code></a> for details).</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.DriftDiffusionIntegrator.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.DriftDiffusionIntegrator.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>number or np.array</em> â current input value, which represents the stimulus component of drift.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.DriftDiffusionIntegrator.rate">
<code class="descname">rate</code><a class="headerlink" href="#Function.DriftDiffusionIntegrator.rate" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float or 1d np.array</em> â determines the rate of integration based on current and prior values.  If integration_type is set to ADAPTIVE,
all elements must be between 0 and 1 (0 = no change; 1 = instantaneous change). If it has a single element, it
applies to all elements of <a class="reference internal" href="#Function.DriftDiffusionIntegrator.variable" title="Function.DriftDiffusionIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>;  if it has more than one element, each element
applies to the corresponding element of <a class="reference internal" href="#Function.DriftDiffusionIntegrator.variable" title="Function.DriftDiffusionIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.DriftDiffusionIntegrator.noise">
<code class="descname">noise</code><a class="headerlink" href="#Function.DriftDiffusionIntegrator.noise" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float, function, list, or 1d np.array</em> â scales the random value to be added in each call to <a href="#id5"><span class="problematic" id="id6">`</span></a>function &lt;DriftDiffusionIntegrator.function&gt;</p>
<p>Noise must be specified as a float (or list or array of floats) because this
value will be used to construct the standard DDM probability distribution.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.DriftDiffusionIntegrator.time_step_size">
<code class="descname">time_step_size</code><a class="headerlink" href="#Function.DriftDiffusionIntegrator.time_step_size" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float</em> â determines the timing precision of the integration process and is used to scale the <a class="reference internal" href="#Function.DriftDiffusionIntegrator.noise" title="Function.DriftDiffusionIntegrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a> parameter appropriately.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.DriftDiffusionIntegrator.t0">
<code class="descname">t0</code><a class="headerlink" href="#Function.DriftDiffusionIntegrator.t0" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float</em> â determines the start time of the integration process and is used to compute the RESPONSE_TIME output state of
the DDM Mechanism.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.DriftDiffusionIntegrator.initializer">
<code class="descname">initializer</code><a class="headerlink" href="#Function.DriftDiffusionIntegrator.initializer" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float, 1d np.array or list</em> â determines the starting value for integration (i.e., the value to which
<a class="reference internal" href="#Function.DriftDiffusionIntegrator.previous_value" title="Function.DriftDiffusionIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a> is set.</p>
<p>If initializer is a list or array, it must be the same length as <code class="xref any docutils literal"><span class="pre">variable</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.DriftDiffusionIntegrator.previous_time">
<code class="descname">previous_time</code><a class="headerlink" href="#Function.DriftDiffusionIntegrator.previous_time" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float</em> â stores previous time at which the function was executed and accumulates with each execution according to
<code class="xref any docutils literal"><span class="pre">time_step_size</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.DriftDiffusionIntegrator.previous_value">
<code class="descname">previous_value</code><a class="headerlink" href="#Function.DriftDiffusionIntegrator.previous_value" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d np.array : default ClassDefaults.variable</em> â stores previous value with which <a class="reference internal" href="#Function.DriftDiffusionIntegrator.variable" title="Function.DriftDiffusionIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> is integrated.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.DriftDiffusionIntegrator.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.DriftDiffusionIntegrator.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Mechanism</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.DriftDiffusionIntegrator.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.DriftDiffusionIntegrator.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.DriftDiffusionIntegrator.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 2&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.DriftDiffusionIntegrator.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return: One time step of evidence accumulation according to the Drift Diffusion Model</p>
<p>previous_value + rate * variable * time_step_size +  * random
sample from Normal distribution</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>number</em><em>, </em><em>list</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â the stimulus component of drift rate in the Drift Diffusion Model.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>updated value of integral</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2d np.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.OrnsteinUhlenbeckIntegrator">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">OrnsteinUhlenbeckIntegrator</code><span class="sig-paren">(</span><em>default_variable=None</em>, <em>rate=1.0</em>, <em>noise=0.0</em>, <em>scale: parameter_spec = 1.0</em>, <em>offset: parameter_spec = 0.0</em>, <em>time_step_size=1.0</em>, <em>t0=0.0</em>, <em>initializer</em>, <em>params=None</em>, <em>owner=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.OrnsteinUhlenbeckIntegrator" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="ornsteinuhlenbeckintegrator">Accumulate evidence overtime based on a stimulus, noise, decay, and previous position.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>default_variable</strong> (<em>number</em><em>, </em><em>list</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â specifies a template for the value to be integrated;  if it is a list or array, each element is independently
integrated.</li>
<li><strong>rate</strong> (<em>float</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 1.0</em>) â specifies the rate of integration.  If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">variable</span></code> (see <a class="reference internal" href="#Function.OrnsteinUhlenbeckIntegrator.rate" title="Function.OrnsteinUhlenbeckIntegrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> for
details).</li>
<li><strong>noise</strong> (<em>float</em><em>, </em><em>PsyNeuLink Function</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 0.0</em>) â specifies random value to be added in each call to <a class="reference internal" href="#Function.OrnsteinUhlenbeckIntegrator.function" title="Function.OrnsteinUhlenbeckIntegrator.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>. (see
<a class="reference internal" href="#Function.OrnsteinUhlenbeckIntegrator.noise" title="Function.OrnsteinUhlenbeckIntegrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a> for details).</li>
<li><strong>time_step_size</strong> (<em>float : default 0.0</em>) â determines the timing precision of the integration process (see <a class="reference internal" href="#Function.OrnsteinUhlenbeckIntegrator.time_step_size" title="Function.OrnsteinUhlenbeckIntegrator.time_step_size"><code class="xref any py py-attr docutils literal"><span class="pre">time_step_size</span></code></a> for details.</li>
<li><strong>t0</strong> (<em>float : default 0.0</em>) â represents the starting time of the model and is used to compute
<a class="reference internal" href="#Function.OrnsteinUhlenbeckIntegrator.previous_time" title="Function.OrnsteinUhlenbeckIntegrator.previous_time"><code class="xref any py py-attr docutils literal"><span class="pre">previous_time</span></code></a></li>
<li><strong>float</strong><strong>, </strong><strong>list</strong><strong> or </strong><strong>1d np.array</strong> (<a class="reference internal" href="#Function.Integrator.initializer" title="Function.Integrator.initializer"><em>initializer</em></a>) â specifies starting value for integration.  If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">default_variable</span></code> (see <a class="reference internal" href="#Function.OrnsteinUhlenbeckIntegrator.initializer" title="Function.OrnsteinUhlenbeckIntegrator.initializer"><code class="xref any py py-attr docutils literal"><span class="pre">initializer</span></code></a> for details).</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.OrnsteinUhlenbeckIntegrator.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.OrnsteinUhlenbeckIntegrator.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>number or np.array</em> â current input value which represents the stimulus component of drift. The product of
<a class="reference internal" href="#Function.OrnsteinUhlenbeckIntegrator.variable" title="Function.OrnsteinUhlenbeckIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> and <a class="reference internal" href="#Function.OrnsteinUhlenbeckIntegrator.rate" title="Function.OrnsteinUhlenbeckIntegrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> is multiplied
by <a class="reference internal" href="#Function.OrnsteinUhlenbeckIntegrator.time_step_size" title="Function.OrnsteinUhlenbeckIntegrator.time_step_size"><code class="xref any py py-attr docutils literal"><span class="pre">time_step_size</span></code></a> to model the accumulation of evidence during
one step.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.OrnsteinUhlenbeckIntegrator.rate">
<code class="descname">rate</code><a class="headerlink" href="#Function.OrnsteinUhlenbeckIntegrator.rate" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float or 1d np.array</em> â represents the attentional component of drift. The product of <a class="reference internal" href="#Function.OrnsteinUhlenbeckIntegrator.rate" title="Function.OrnsteinUhlenbeckIntegrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> and
<a class="reference internal" href="#Function.OrnsteinUhlenbeckIntegrator.variable" title="Function.OrnsteinUhlenbeckIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> is multiplied by
<a class="reference internal" href="#Function.OrnsteinUhlenbeckIntegrator.time_step_size" title="Function.OrnsteinUhlenbeckIntegrator.time_step_size"><code class="xref any py py-attr docutils literal"><span class="pre">time_step_size</span></code></a> to model the accumulation of evidence during
one step.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.OrnsteinUhlenbeckIntegrator.noise">
<code class="descname">noise</code><a class="headerlink" href="#Function.OrnsteinUhlenbeckIntegrator.noise" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float, function, list, or 1d np.array</em> â scales the random value to be added in each call to <a class="reference internal" href="#Function.OrnsteinUhlenbeckIntegrator.function" title="Function.OrnsteinUhlenbeckIntegrator.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a></p>
<p>Noise must be specified as a float (or list or array of floats) because this
value will be used to construct the standard DDM probability distribution.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.OrnsteinUhlenbeckIntegrator.time_step_size">
<code class="descname">time_step_size</code><a class="headerlink" href="#Function.OrnsteinUhlenbeckIntegrator.time_step_size" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float</em> â determines the timing precision of the integration process and is used to scale the <a class="reference internal" href="#Function.OrnsteinUhlenbeckIntegrator.noise" title="Function.OrnsteinUhlenbeckIntegrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a> parameter appropriately.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.OrnsteinUhlenbeckIntegrator.initializer">
<code class="descname">initializer</code><a class="headerlink" href="#Function.OrnsteinUhlenbeckIntegrator.initializer" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float, 1d np.array or list</em> â determines the starting value for integration (i.e., the value to which
<a class="reference internal" href="#Function.OrnsteinUhlenbeckIntegrator.previous_value" title="Function.OrnsteinUhlenbeckIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a> is originally set.)</p>
<p>If initializer is a list or array, it must be the same length as <code class="xref any docutils literal"><span class="pre">variable</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.OrnsteinUhlenbeckIntegrator.previous_value">
<code class="descname">previous_value</code><a class="headerlink" href="#Function.OrnsteinUhlenbeckIntegrator.previous_value" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d np.array : default ClassDefaults.variable</em> â stores previous value with which <a class="reference internal" href="#Function.OrnsteinUhlenbeckIntegrator.variable" title="Function.OrnsteinUhlenbeckIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> is integrated.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.OrnsteinUhlenbeckIntegrator.previous_time">
<code class="descname">previous_time</code><a class="headerlink" href="#Function.OrnsteinUhlenbeckIntegrator.previous_time" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float</em> â stores previous time at which the function was executed and accumulates with each execution according to
<code class="xref any docutils literal"><span class="pre">time_step_size</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.OrnsteinUhlenbeckIntegrator.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.OrnsteinUhlenbeckIntegrator.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Mechanism</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.OrnsteinUhlenbeckIntegrator.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.OrnsteinUhlenbeckIntegrator.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.OrnsteinUhlenbeckIntegrator.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 2&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.OrnsteinUhlenbeckIntegrator.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return: One time step of evidence accumulation according to the Ornstein Uhlenbeck Model</p>
<p>previous_value + decay * (previous_value -  rate * variable) +  * random
sample from Normal distribution</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>variable</strong> (<em>number</em><em>, </em><em>list</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â the stimulus component of drift rate in the Drift Diffusion Model.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>params <span class="classifier-delimiter">:</span> <span class="classifier">Optional[Dict[param keyword, param value]]</span></dt>
<dd>a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</dd>
<dt>time_scale <span class="classifier-delimiter">:</span> <span class="classifier">TimeScale</span> <span class="classifier-delimiter">:</span> <span class="classifier">default TimeScale.TRIAL</span></dt>
<dd>specifies whether the function is executed on the time_step or trial time scale.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>updated value of integral</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">2d np.array</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.FHNIntegrator">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">FHNIntegrator</code><span class="sig-paren">(</span><em>default_variable=None</em>, <em>rate=1.0</em>, <em>noise=0.0</em>, <em>scale: parameter_spec = 1.0</em>, <em>offset: parameter_spec = 0.0</em>, <em>initial_w=0.0</em>, <em>initial_v=0.0</em>, <em>time_step_size=0.1</em>, <em>t_0=0.0</em>, <em>a_v=-1/3</em>, <em>b_v=0.0</em>, <em>c_v=1.0</em>, <em>d_v=0.0</em>, <em>e_v=-1.0</em>, <em>f_v=1.0</em>, <em>time_constant_v=1.0</em>, <em>a_w=1.0</em>, <em>b_w=-0.8</em>, <em>c_w=0.7</em>, <em>mode=1.0</em>, <em>uncorrelated_activity=0.0               time_constant_w = 12.5</em>, <em>params=None</em>, <em>owner=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.FHNIntegrator" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="fhnintegrator">Implements the Fitzhugh-Nagumo model using the 4th order Runge Kutta method of numerical integration.</p>
<p>In order to support several common representations of the model, the FHNIntegrator includes many parameters, some of
which would not be sensible to use in combination.</p>
<p>The most general form of the FHNIntegrator function, with all of its arguments, is:</p>
<blockquote>
<div><p>time_constant_v * dv/dt = a_v * v^3 + (1 + threshold) * b_v * v^2 + (- threshold) * c_v * v^2 + d_v + e_v *
w + f_v * I_ext</p>
<p>time_constant_w * dw/dt = mode * a_w * v + b_w * w + c_w + (1 - self.mode) * self.uncorrelated_activity</p>
</div></blockquote>
<p>The three formulations that the FHNIntegrator was designed to allow are:</p>
<p><strong>Fitzhugh-Nagumo Model</strong></p>
<blockquote>
<div><blockquote>
<div><p>dv/dt = v - (v^3)/3 -w + I_ext</p>
<p>T*dw/dt = v + a - b*w</p>
</div></blockquote>
<p>where dw/dt often has the following parameters:</p>
<blockquote>
<div>dw/dt = 0.08(v + 0.7 - 0.8*w)</div></blockquote>
<p>The FHNIntegratorâs default parameter values map the above equations and parameters onto the PsyNeuLink
implementation.</p>
</div></blockquote>
<p><strong>Modified FHN Model</strong></p>
<blockquote>
<div><blockquote>
<div><p>dv/dt = v*(a-v)(v-1) -w + I_ext</p>
<p>dw/dt = b*v - c*w</p>
</div></blockquote>
<p>In order to reproduce the modified FHN model, the FHNIntegratorâs parameters must be set as follows:</p>
<blockquote>
<div><p>a â&gt; <a class="reference internal" href="#Function.FHNIntegrator.threshold" title="Function.FHNIntegrator.threshold"><code class="xref any py py-attr docutils literal"><span class="pre">threshold</span></code></a></p>
<p>time_constant_w = mode = time_constant_v = a_v = b_v = f_v = 1.0</p>
<p>c_v = e_v = -1.0</p>
<p>uncorrelated_activity = d_v = 0.0;</p>
</div></blockquote>
<p><a class="reference external" href="http://pcwww.liv.ac.uk/~bnvasiev/Past%20students/Mahbub_549.pdf">Mahbub Khan (2013)</a> provides a nice summary
of why this formulation is useful.</p>
</div></blockquote>
<p><a class="reference external" href="http://www.sciencedirect.com/science/article/pii/S0893608002000552?via%3Dihub">Gilzenrat (2002)</a> <strong>Implementation
of the Modified FHN Model</strong></p>
<blockquote>
<div><blockquote>
<div><p>time_constant_v * dv/dt = v*(a-v)(v-1) -w + b*I_ext</p>
<p>time_constant_w * dw/dt = c*v + (1-c)*d - w</p>
</div></blockquote>
<p>In order to reproduce the Gilzenrat formulation, the FHNIntegratorâs parameters must be set as follows:</p>
<blockquote>
<div><p>a â&gt; <a class="reference internal" href="#Function.FHNIntegrator.threshold" title="Function.FHNIntegrator.threshold"><code class="xref any py py-attr docutils literal"><span class="pre">threshold</span></code></a></p>
<p>b â&gt; negative <a class="reference internal" href="#Function.FHNIntegrator.e_v" title="Function.FHNIntegrator.e_v"><code class="xref any py py-attr docutils literal"><span class="pre">e_v</span></code></a></p>
<p>c â&gt; <a class="reference internal" href="#Function.FHNIntegrator.mode" title="Function.FHNIntegrator.mode"><code class="xref any py py-attr docutils literal"><span class="pre">mode</span></code></a></p>
<p>d â&gt; <a class="reference internal" href="#Function.FHNIntegrator.uncorrelated_activity" title="Function.FHNIntegrator.uncorrelated_activity"><code class="xref any py py-attr docutils literal"><span class="pre">uncorrelated_activity</span></code></a></p>
<p>a_v = b_v = f_v = 1.0 ; c_v = -1.0 ; d_v = 0.0;</p>
</div></blockquote>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>default_variable</strong> (<em>number</em><em>, </em><em>list</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â specifies a template for the external stimulus</li>
<li><strong>initial_w</strong> (<em>float</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 0.0</em>) â specifies starting value for integration of dw/dt.  If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">default_variable</span></code></li>
<li><strong>initial_v</strong> (<em>float</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 0.0</em>) â specifies starting value for integration of dv/dt.  If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">default_variable</span></code></li>
<li><strong>time_step_size</strong> (<em>float : default 0.1</em>) â specifies the time step size of numerical integration</li>
<li><strong>t_0</strong> (<em>float : default 0.0</em>) â specifies starting value for time</li>
<li><strong>a_v</strong> (<em>float : default -1/3</em>) â coefficient on the v^3 term of the dv/dt equation</li>
<li><strong>b_v</strong> (<em>float : default 0.0</em>) â coefficient on the v^2 term of the dv/dt equation</li>
<li><strong>c_v</strong> (<em>float : default 1.0</em>) â coefficient on the v term of the dv/dt equation</li>
<li><strong>d_v</strong> (<em>float : default 0.0</em>) â constant term in the dv/dt equation</li>
<li><strong>e_v</strong> (<em>float : default -1.0</em>) â coefficient on the w term in the dv/dt equation</li>
<li><strong>f_v</strong> (<em>float : default  1.0</em>) â coefficient on the external stimulus (<a class="reference internal" href="#Function.FHNIntegrator.variable" title="Function.FHNIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>) term in the dv/dt equation</li>
<li><strong>time_constant_v</strong> (<em>float : default 1.0</em>) â scaling factor on the dv/dt equation</li>
<li><strong>a_w</strong> (<em>float : default 1.0</em><em>,</em>) â coefficient on the v term of the dw/dt equation</li>
<li><strong>b_w</strong> (<em>float : default -0.8</em><em>,</em>) â coefficient on the w term of the dv/dt equation</li>
<li><strong>c_w</strong> (<em>float : default 0.7</em><em>,</em>) â constant term in the dw/dt equation</li>
<li><strong>threshold</strong> (<em>float : default -1.0</em>) â specifies a value of the input below which the LC will tend not to respond and above which it will</li>
<li><strong>mode</strong> (<em>float : default 1.0</em>) â coefficient which simulates electrotonic coupling by scaling the values of dw/dt such that the v term
(representing the input from the LC) increases when the uncorrelated_activity term (representing baseline
activity) decreases</li>
<li><strong>uncorrelated_activity</strong> (<em>float : default 0.0</em>) â constant term in the dw/dt equation</li>
<li><strong>time_constant_w</strong> (<em>float : default 12.5</em>) â scaling factor on the dv/dt equation</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.FHNIntegrator.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.FHNIntegrator.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>number or np.array</em> â External stimulus</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.previous_v">
<code class="descname">previous_v</code><a class="headerlink" href="#Function.FHNIntegrator.previous_v" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d np.array : default ClassDefaults.variable</em> â stores accumulated value of v during integration</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.previous_w">
<code class="descname">previous_w</code><a class="headerlink" href="#Function.FHNIntegrator.previous_w" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d np.array : default ClassDefaults.variable</em> â stores accumulated value of w during integration</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.previous_t">
<code class="descname">previous_t</code><a class="headerlink" href="#Function.FHNIntegrator.previous_t" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float</em> â stores accumulated value of time, which is incremented by time_step_size on each execution of the function</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.FHNIntegrator.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Mechanism</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.initial_w">
<code class="descname">initial_w</code><a class="headerlink" href="#Function.FHNIntegrator.initial_w" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float, list or 1d np.array : default 0.0</em> â specifies starting value for integration of dw/dt.  If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">default_variable</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.initial_v">
<code class="descname">initial_v</code><a class="headerlink" href="#Function.FHNIntegrator.initial_v" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float, list or 1d np.array : default 0.0</em> â specifies starting value for integration of dv/dt.  If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">default_variable</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.time_step_size">
<code class="descname">time_step_size</code><a class="headerlink" href="#Function.FHNIntegrator.time_step_size" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 0.1</em> â specifies the time step size of numerical integration</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.t_0">
<code class="descname">t_0</code><a class="headerlink" href="#Function.FHNIntegrator.t_0" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 0.0</em> â specifies starting value for time</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.a_v">
<code class="descname">a_v</code><a class="headerlink" href="#Function.FHNIntegrator.a_v" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default -1/3</em> â coefficient on the v^3 term of the dv/dt equation</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.b_v">
<code class="descname">b_v</code><a class="headerlink" href="#Function.FHNIntegrator.b_v" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 0.0</em> â coefficient on the v^2 term of the dv/dt equation</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.c_v">
<code class="descname">c_v</code><a class="headerlink" href="#Function.FHNIntegrator.c_v" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 1.0</em> â coefficient on the v term of the dv/dt equation</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.d_v">
<code class="descname">d_v</code><a class="headerlink" href="#Function.FHNIntegrator.d_v" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 0.0</em> â constant term in the dv/dt equation</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.e_v">
<code class="descname">e_v</code><a class="headerlink" href="#Function.FHNIntegrator.e_v" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default -1.0</em> â coefficient on the w term in the dv/dt equation</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.f_v">
<code class="descname">f_v</code><a class="headerlink" href="#Function.FHNIntegrator.f_v" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default  1.0</em> â coefficient on the external stimulus (âvariable &lt;FHNIntegrator.variable&gt;`) term in the dv/dt equation</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.time_constant_v">
<code class="descname">time_constant_v</code><a class="headerlink" href="#Function.FHNIntegrator.time_constant_v" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 1.0</em> â scaling factor on the dv/dt equation</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.a_w">
<code class="descname">a_w</code><a class="headerlink" href="#Function.FHNIntegrator.a_w" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 1.0</em> â coefficient on the v term of the dw/dt equation</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.b_w">
<code class="descname">b_w</code><a class="headerlink" href="#Function.FHNIntegrator.b_w" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default -0.8</em> â coefficient on the w term of the dv/dt equation</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.c_w">
<code class="descname">c_w</code><a class="headerlink" href="#Function.FHNIntegrator.c_w" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 0.7</em> â constant term in the dw/dt equation</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.threshold">
<code class="descname">threshold</code><a class="headerlink" href="#Function.FHNIntegrator.threshold" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default -1.0</em> â coefficient that scales both the v^2 [ (1+threshold)*v^2 ] and v [ (-threshold)*v ] terms in the dv/dt equation
under a specific formulation of the FHN equations, the threshold parameter behaves as a âthreshold of
excitationâ, and has the following relationship with variable (the external stimulus):</p>
<blockquote>
<div><ul class="simple">
<li>when the external stimulus is below the threshold of excitation, the system is either in a stable state,
or will emit a single excitation spike, then reach a stable state. The behavior varies depending on the
magnitude of the difference between the threshold and the stimulus.</li>
<li>when the external stimulus is equal to or above the threshold of excitation, the system is
unstable, and will emit many excitation spikes</li>
<li>when the external stimulus is too far above the threshold of excitation, the system will emit some
excitation spikes before reaching a stable state.</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.mode">
<code class="descname">mode</code><a class="headerlink" href="#Function.FHNIntegrator.mode" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 1.0</em> â coefficient which simulates electrotonic coupling by scaling the values of dw/dt such that the v term
(representing the input from the LC) increases when the uncorrelated_activity term (representing baseline
activity) decreases</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.uncorrelated_activity">
<code class="descname">uncorrelated_activity</code><a class="headerlink" href="#Function.FHNIntegrator.uncorrelated_activity" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 0.0</em> â constant term in the dw/dt equation</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.time_constant_w">
<code class="descname">time_constant_w</code><a class="headerlink" href="#Function.FHNIntegrator.time_constant_w" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 12.5</em> â scaling factor on the dv/dt equation</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.FHNIntegrator.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.FHNIntegrator.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.FHNIntegrator.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 2&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.FHNIntegrator.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return: current v, current w</p>
<p>The model is defined by the following system of differential equations:</p>
<blockquote>
<div><p>time_constant_v * dv/dt = a_v * v^3 + (1 + threshold) * b_v * v^2 + (- threshold) * c_v * v^2 + d_v + e_v *
w + f_v * I_ext</p>
<p>time_constant_w * dw/dt = mode * a_w * v + b_w * w + c_w + (1 - self.mode) * self.uncorrelated_activity</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>current value of v , current value of w</strong></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float, list, or np.array</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.AccumulatorIntegrator">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">AccumulatorIntegrator</code><span class="sig-paren">(</span><em>default_variable=None</em>, <em>rate=1.0</em>, <em>noise=0.0</em>, <em>scale: parameter_spec = 1.0</em>, <em>offset: parameter_spec = 0.0</em>, <em>initializer</em>, <em>params=None</em>, <em>owner=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.AccumulatorIntegrator" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="accumulatorintegrator">Integrates prior value by multiplying <a class="reference internal" href="#Function.AccumulatorIntegrator.previous_value" title="Function.AccumulatorIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a> by <a class="reference internal" href="#Function.Integrator.rate" title="Function.Integrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> and adding <a class="reference internal" href="#Function.AccumulatorIntegrator.increment" title="Function.AccumulatorIntegrator.increment"><code class="xref any py py-attr docutils literal"><span class="pre">increment</span></code></a> and  <a class="reference internal" href="#Function.AccumulatorIntegrator.noise" title="Function.AccumulatorIntegrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a>. Ignores <a class="reference internal" href="#Function.Integrator.variable" title="Function.Integrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>default_variable</strong> (<em>number</em><em>, </em><em>list</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â specifies a template for the value to be integrated;  if it is a list or array, each element is independently
integrated.</li>
<li><strong>rate</strong> (<em>float</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 1.0</em>) â specifies the multiplicative decrement of <a class="reference internal" href="#Function.AccumulatorIntegrator.previous_value" title="Function.AccumulatorIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a> (i.e.,
the rate of exponential decay).  If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">variable</span></code>.</li>
<li><strong>increment</strong> (<em>float</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 0.0</em>) â specifies an amount to be added to <a class="reference internal" href="#Function.AccumulatorIntegrator.previous_value" title="Function.AccumulatorIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a> in each call to
<a class="reference internal" href="#Function.AccumulatorIntegrator.function" title="Function.AccumulatorIntegrator.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a> (see <a class="reference internal" href="#Function.AccumulatorIntegrator.increment" title="Function.AccumulatorIntegrator.increment"><code class="xref any py py-attr docutils literal"><span class="pre">increment</span></code></a> for details).
If it is a list or array, it must be the same length as <code class="xref any docutils literal"><span class="pre">variable</span></code>
(see <a class="reference internal" href="#Function.AccumulatorIntegrator.increment" title="Function.AccumulatorIntegrator.increment"><code class="xref any py py-attr docutils literal"><span class="pre">increment</span></code></a> for details).</li>
<li><strong>noise</strong> (<em>float</em><em>, </em><em>PsyNeuLink Function</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 0.0</em>) â specifies random value to be added to <a class="reference internal" href="#Function.AccumulatorIntegrator.previous_value" title="Function.AccumulatorIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">prevous_value</span></code></a> in each call to
<a class="reference internal" href="#Function.AccumulatorIntegrator.function" title="Function.AccumulatorIntegrator.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>. If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">variable</span></code> (see <a class="reference internal" href="#Function.AccumulatorIntegrator.noise" title="Function.AccumulatorIntegrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a> for details).</li>
<li><strong>float</strong><strong>, </strong><strong>list</strong><strong> or </strong><strong>1d np.array</strong> (<a class="reference internal" href="#Function.Integrator.initializer" title="Function.Integrator.initializer"><em>initializer</em></a>) â specifies starting value for integration.  If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">default_variable</span></code> (see <a class="reference internal" href="#Function.AccumulatorIntegrator.initializer" title="Function.AccumulatorIntegrator.initializer"><code class="xref any py py-attr docutils literal"><span class="pre">initializer</span></code></a> for details).</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.AccumulatorIntegrator.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.AccumulatorIntegrator.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>number or np.array</em> â <strong>Ignored</strong> by the AccumulatorIntegrator function. Refer to SimpleIntegrator or AdaptiveIntegrator for
integrator functions that depend on both a prior value and a new value (variable).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AccumulatorIntegrator.rate">
<code class="descname">rate</code><a class="headerlink" href="#Function.AccumulatorIntegrator.rate" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float or 1d np.array</em> â determines the multiplicative decrement of <a class="reference internal" href="#Function.AccumulatorIntegrator.previous_value" title="Function.AccumulatorIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a> (i.e., the
rate of exponential decay) in each call to <a class="reference internal" href="#Function.AccumulatorIntegrator.function" title="Function.AccumulatorIntegrator.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>.  If it is a list or
array, it must be the same length as <code class="xref any docutils literal"><span class="pre">variable</span></code> and each element is
used to multiply the corresponding element of <a class="reference internal" href="#Function.AccumulatorIntegrator.previous_value" title="Function.AccumulatorIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a> (i.e.,
it is used for Hadamard multiplication).  If it is a scalar or has a single element, its value is used to
multiply all the elements of <a class="reference internal" href="#Function.AccumulatorIntegrator.previous_value" title="Function.AccumulatorIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AccumulatorIntegrator.increment">
<code class="descname">increment</code><a class="headerlink" href="#Function.AccumulatorIntegrator.increment" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float, function, list, or 1d np.array</em> â determines the amount added to <a class="reference internal" href="#Function.AccumulatorIntegrator.previous_value" title="Function.AccumulatorIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a> in each call to
<a class="reference internal" href="#Function.AccumulatorIntegrator.function" title="Function.AccumulatorIntegrator.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>.  If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">variable</span></code> and each element is added to the corresponding element of
<a class="reference internal" href="#Function.AccumulatorIntegrator.previous_value" title="Function.AccumulatorIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a> (i.e., it is used for Hadamard addition).  If it is a
scalar or has a single element, its value is added to all the elements of <a class="reference internal" href="#Function.AccumulatorIntegrator.previous_value" title="Function.AccumulatorIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AccumulatorIntegrator.noise">
<code class="descname">noise</code><a class="headerlink" href="#Function.AccumulatorIntegrator.noise" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float, function, list, or 1d np.array</em> â determines a random value to be added in each call to <a class="reference internal" href="#Function.AccumulatorIntegrator.function" title="Function.AccumulatorIntegrator.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>.
If it is a list or array, it must be the same length as <code class="xref any docutils literal"><span class="pre">variable</span></code> and
each element is added to the corresponding element of <a class="reference internal" href="#Function.AccumulatorIntegrator.previous_value" title="Function.AccumulatorIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a>
(i.e., it is used for Hadamard addition).  If it is a scalar or has a single element, its value is added to all
the elements of <a class="reference internal" href="#Function.AccumulatorIntegrator.previous_value" title="Function.AccumulatorIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a>.  If it is a function, it will be
executed separately and added to each element.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In order to generate random noise, a probability distribution function should be selected (see
<code class="xref any docutils literal"><span class="pre">Distribution</span> <span class="pre">Functions</span></code> for details), which will generate a new noise value from
its distribution on each execution. If noise is specified as a float or as a function with a fixed output,
then the noise will simply be an offset that remains the same across all executions.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="Function.AccumulatorIntegrator.initializer">
<code class="descname">initializer</code><a class="headerlink" href="#Function.AccumulatorIntegrator.initializer" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float, 1d np.array or list</em> â determines the starting value for integration (i.e., the value to which <a class="reference internal" href="#Function.AccumulatorIntegrator.previous_value" title="Function.AccumulatorIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a> is set. If initializer is a list or array, it must be the same length
as <code class="xref any docutils literal"><span class="pre">variable</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AccumulatorIntegrator.previous_value">
<code class="descname">previous_value</code><a class="headerlink" href="#Function.AccumulatorIntegrator.previous_value" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d np.array : default ClassDefaults.variable</em> â stores previous value to which <a class="reference internal" href="#Function.AccumulatorIntegrator.rate" title="Function.AccumulatorIntegrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> and <a class="reference internal" href="#Function.AccumulatorIntegrator.noise" title="Function.AccumulatorIntegrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a>
will be added.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AccumulatorIntegrator.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.AccumulatorIntegrator.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Mechanism</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AccumulatorIntegrator.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.AccumulatorIntegrator.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.AccumulatorIntegrator.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 2&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.AccumulatorIntegrator.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return: <a class="reference internal" href="#Function.ConstantIntegrator.previous_value" title="Function.ConstantIntegrator.previous_value"><code class="xref any py py-attr docutils literal"><span class="pre">previous_value</span></code></a> combined with <a class="reference internal" href="#Function.ConstantIntegrator.rate" title="Function.ConstantIntegrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> and
<a class="reference internal" href="#Function.ConstantIntegrator.noise" title="Function.ConstantIntegrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) â specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>updated value of integral</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2d np.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.AGTUtilityIntegrator">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">AGTUtilityIntegrator</code><span class="sig-paren">(</span><em>default_variable=None</em>, <em>rate=1.0</em>, <em>noise=0.0</em>, <em>scale: parameter_spec = 1.0</em>, <em>offset: parameter_spec = 0.0</em>, <em>initializer</em>, <em>initial_short_term_utility = 0.0</em>, <em>initial_long_term_utility = 0.0</em>, <em>short_term_gain = 1.0</em>, <em>long_term_gain =1.0</em>, <em>short_term_bias = 0.0</em>, <em>long_term_bias=0.0</em>, <em>short_term_rate=1.0</em>, <em>long_term_rate=1.0</em>, <em>params=None</em>, <em>owner=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.AGTUtilityIntegrator" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="agtutilityintegrator">Computes an exponentially weighted moving average on the variable using two sets of parameters:</p>
<p>short_term_utility = (1 - <a class="reference internal" href="#Function.AGTUtilityIntegrator.short_term_rate" title="Function.AGTUtilityIntegrator.short_term_rate"><code class="xref any py py-attr docutils literal"><span class="pre">short_term_rate</span></code></a>) * <a class="reference internal" href="#Function.AGTUtilityIntegrator.previous_short_term_utility" title="Function.AGTUtilityIntegrator.previous_short_term_utility"><code class="xref any py py-attr docutils literal"><span class="pre">previous_short_term_utility</span></code></a> + <a class="reference internal" href="#Function.AGTUtilityIntegrator.short_term_rate" title="Function.AGTUtilityIntegrator.short_term_rate"><code class="xref any py py-attr docutils literal"><span class="pre">short_term_rate</span></code></a> *
<a class="reference internal" href="#Function.AGTUtilityIntegrator.variable" title="Function.AGTUtilityIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a></p>
<p>long_term_utility = (1 - <a class="reference internal" href="#Function.AGTUtilityIntegrator.long_term_rate" title="Function.AGTUtilityIntegrator.long_term_rate"><code class="xref any py py-attr docutils literal"><span class="pre">long_term_rate</span></code></a>) * <a class="reference internal" href="#Function.AGTUtilityIntegrator.previous_long_term_utility" title="Function.AGTUtilityIntegrator.previous_long_term_utility"><code class="xref any py py-attr docutils literal"><span class="pre">previous_long_term_utility</span></code></a> + <a class="reference internal" href="#Function.AGTUtilityIntegrator.long_term_rate" title="Function.AGTUtilityIntegrator.long_term_rate"><code class="xref any py py-attr docutils literal"><span class="pre">long_term_rate</span></code></a> *
<a class="reference internal" href="#Function.AGTUtilityIntegrator.variable" title="Function.AGTUtilityIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a></p>
<p>then takes the logistic of each utility value, using the corresponding (short term and long term) gain and bias.</p>
<p>Finally, computes a single value which combines the two values according to:</p>
<p>value = [1-short_term_utility_logistic]*long_term_utility_logistic</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rate</strong> (<em>float</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 1.0</em>) â specifies the overall smoothing factor of the EWMA used to combine the long term and short term utility values</li>
<li><strong>noise</strong> (<em>float</em><em>, </em><em>PsyNeuLink Function</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 0.0</em>) â TBI?</li>
<li><strong>initial_short_term_utility</strong> (<em>float : default 0.0</em>) â specifies starting value for integration of short_term_utility</li>
<li><strong>initial_long_term_utility</strong> (<em>float : default 0.0</em>) â specifies starting value for integration of long_term_utility</li>
<li><strong>short_term_gain</strong> (<em>float : default 1.0</em>) â specifies gain for logistic function applied to short_term_utility</li>
<li><strong>long_term_gain</strong> (<em>float : default 1.0</em>) â specifies gain for logistic function applied to long_term_utility</li>
<li><strong>short_term_bias</strong> (<em>float : default 0.0</em>) â specifies bias for logistic function applied to short_term_utility</li>
<li><strong>long_term_bias</strong> (<em>float : default 0.0</em>) â specifies bias for logistic function applied to long_term_utility</li>
<li><strong>short_term_rate</strong> (<em>float : default 1.0</em>) â specifies smoothing factor of EWMA filter applied to short_term_utility</li>
<li><strong>long_term_rate</strong> (<em>float : default 1.0</em>) â specifies smoothing factor of EWMA filter applied to long_term_utility</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.AGTUtilityIntegrator.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.AGTUtilityIntegrator.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>number or np.array</em> â current input value used in both the short term and long term EWMA computations</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AGTUtilityIntegrator.noise">
<code class="descname">noise</code><a class="headerlink" href="#Function.AGTUtilityIntegrator.noise" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float, PsyNeuLink Function, list or 1d np.array : default 0.0</em> â TBI?</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AGTUtilityIntegrator.initial_short_term_utility">
<code class="descname">initial_short_term_utility</code><a class="headerlink" href="#Function.AGTUtilityIntegrator.initial_short_term_utility" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 0.0</em> â specifies starting value for integration of short_term_utility</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AGTUtilityIntegrator.initial_long_term_utility">
<code class="descname">initial_long_term_utility</code><a class="headerlink" href="#Function.AGTUtilityIntegrator.initial_long_term_utility" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 0.0</em> â specifies starting value for integration of long_term_utility</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AGTUtilityIntegrator.short_term_gain">
<code class="descname">short_term_gain</code><a class="headerlink" href="#Function.AGTUtilityIntegrator.short_term_gain" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 1.0</em> â specifies gain for logistic function applied to short_term_utility</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AGTUtilityIntegrator.long_term_gain">
<code class="descname">long_term_gain</code><a class="headerlink" href="#Function.AGTUtilityIntegrator.long_term_gain" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 1.0</em> â specifies gain for logistic function applied to long_term_utility</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AGTUtilityIntegrator.short_term_bias">
<code class="descname">short_term_bias</code><a class="headerlink" href="#Function.AGTUtilityIntegrator.short_term_bias" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 0.0</em> â specifies bias for logistic function applied to short_term_utility</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AGTUtilityIntegrator.long_term_bias">
<code class="descname">long_term_bias</code><a class="headerlink" href="#Function.AGTUtilityIntegrator.long_term_bias" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 0.0</em> â specifies bias for logistic function applied to long_term_utility</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AGTUtilityIntegrator.short_term_rate">
<code class="descname">short_term_rate</code><a class="headerlink" href="#Function.AGTUtilityIntegrator.short_term_rate" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 1.0</em> â specifies smoothing factor of EWMA filter applied to short_term_utility</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AGTUtilityIntegrator.long_term_rate">
<code class="descname">long_term_rate</code><a class="headerlink" href="#Function.AGTUtilityIntegrator.long_term_rate" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 1.0</em> â specifies smoothing factor of EWMA filter applied to long_term_utility</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AGTUtilityIntegrator.previous_short_term_utility">
<code class="descname">previous_short_term_utility</code><a class="headerlink" href="#Function.AGTUtilityIntegrator.previous_short_term_utility" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d np.array</em> â stores previous value with which <a class="reference internal" href="#Function.AGTUtilityIntegrator.variable" title="Function.AGTUtilityIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> is integrated using the EWMA filter and
short term parameters</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AGTUtilityIntegrator.previous_long_term_utility">
<code class="descname">previous_long_term_utility</code><a class="headerlink" href="#Function.AGTUtilityIntegrator.previous_long_term_utility" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d np.array</em> â stores previous value with which <a class="reference internal" href="#Function.AGTUtilityIntegrator.variable" title="Function.AGTUtilityIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> is integrated using the EWMA filter and
long term parameters</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AGTUtilityIntegrator.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.AGTUtilityIntegrator.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Mechanism</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.AGTUtilityIntegrator.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.AGTUtilityIntegrator.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.AGTUtilityIntegrator.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 2&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.AGTUtilityIntegrator.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return: some fraction of <a class="reference internal" href="#Function.AGTUtilityIntegrator.variable" title="Function.AGTUtilityIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> combined with some fraction of <code class="xref any docutils literal"><span class="pre">previous_value</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>number</em><em>, </em><em>list</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â a single value or array of values to be integrated.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>updated value of integral</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2d np.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.BogaczEtAl">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">BogaczEtAl</code><span class="sig-paren">(</span><em>default_variable=ClassDefaults.variable</em>, <em>drift_rate=1.0</em>, <em>threshold=1.0</em>, <em>starting_point=0.0</em>, <em>t0=0.2                                          noise=0.5</em>, <em>params=None</em>, <em>owner=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.BogaczEtAl" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="bogaczetal">Return terminal value of decision variable, mean accuracy, and mean response time computed analytically for the
drift diffusion process as described in <a class="reference external" href="https://www.ncbi.nlm.nih.gov/pubmed/17014301">Bogacz et al (2006)</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>default_variable</strong> (<em>number</em><em>, </em><em>list</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â specifies a template for decision variable(s);  if it is list or array, a separate solution is computed
independently for each element.</li>
<li><strong>drift_rate</strong> (<em>float</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 1.0</em>) â specifies the drift_rate of the drift diffusion process.  If it is a list or array,
it must be the same length as <code class="xref any docutils literal"><span class="pre">default_variable</span></code>.</li>
<li><strong>threshold</strong> (<em>float</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 1.0</em>) â specifies the threshold (boundary) of the drift diffusion process.  If it is a list or array,
it must be the same length as <code class="xref any docutils literal"><span class="pre">default_variable</span></code>.</li>
<li><strong>starting_point</strong> (<em>float</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 1.0</em>) â specifies the initial value of the decision variable for the drift diffusion process.  If it is a list or
array, it must be the same length as <code class="xref any docutils literal"><span class="pre">default_variable</span></code>.</li>
<li><strong>noise</strong> (<em>float</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 0.0</em>) â specifies the noise term (corresponding to the diffusion component) of the drift diffusion process.
If it is a float, it must be a number from 0 to 1.  If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">default_variable</span></code> and all elements must be floats from 0 to 1.</li>
<li><strong>t0</strong> (<em>float</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 0.2</em>) â specifies the non-decision time for solution. If it is a float, it must be a number from 0 to 1.  If it is a
list or array, it must be the same length as  <code class="xref any docutils literal"><span class="pre">default_variable</span></code> and all
elements must be floats from 0 to 1.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.BogaczEtAl.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.BogaczEtAl.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>number or 1d np.array</em> â holds initial value assigned to <code class="xref std std-keyword docutils literal"><span class="pre">default_variable</span></code> argument;
ignored by <code class="xref any docutils literal"><span class="pre">function</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BogaczEtAl.drift_rate">
<code class="descname">drift_rate</code><a class="headerlink" href="#Function.BogaczEtAl.drift_rate" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float or 1d np.array</em> â determines the drift component of the drift diffusion process.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BogaczEtAl.threshold">
<code class="descname">threshold</code><a class="headerlink" href="#Function.BogaczEtAl.threshold" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float or 1d np.array</em> â determines the threshold (boundary) of the drift diffusion process (i.e., at which the integration
process is assumed to terminate).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BogaczEtAl.starting_point">
<code class="descname">starting_point</code><a class="headerlink" href="#Function.BogaczEtAl.starting_point" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float or 1d np.array</em> â determines the initial value of the decision variable for the drift diffusion process.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BogaczEtAl.noise">
<code class="descname">noise</code><a class="headerlink" href="#Function.BogaczEtAl.noise" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float or 1d np.array</em> â determines the diffusion component of the drift diffusion process (used to specify the variance of a
Gaussian random process).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BogaczEtAl.t0">
<code class="descname">t0</code><a class="headerlink" href="#Function.BogaczEtAl.t0" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float or 1d np.array</em> â determines the assumed non-decision time to determine the response time returned by the solution.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BogaczEtAl.bias">
<code class="descname">bias</code><a class="headerlink" href="#Function.BogaczEtAl.bias" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float or 1d np.array</em> â normalized starting point:
(<a class="reference internal" href="#Function.BogaczEtAl.starting_point" title="Function.BogaczEtAl.starting_point"><code class="xref any py py-attr docutils literal"><span class="pre">starting_point</span></code></a> + <a class="reference internal" href="#Function.BogaczEtAl.threshold" title="Function.BogaczEtAl.threshold"><code class="xref any py py-attr docutils literal"><span class="pre">threshold</span></code></a>) /
(2 * <a class="reference internal" href="#Function.BogaczEtAl.threshold" title="Function.BogaczEtAl.threshold"><code class="xref any py py-attr docutils literal"><span class="pre">threshold</span></code></a>)</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BogaczEtAl.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.BogaczEtAl.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Mechanism</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BogaczEtAl.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.BogaczEtAl.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.BogaczEtAl.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 2&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.BogaczEtAl.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return: terminal value of decision variable (equal to threshold), mean accuracy (error rate; ER) and mean
response time (RT)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>2d np.array</em>) â ignored.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) â specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Decision variable, mean ER, mean RT</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">(float, float, float)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Function.BogaczEtAl.derivative">
<code class="descname">derivative</code><span class="sig-paren">(</span><em>output</em>, <em>input</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.BogaczEtAl.derivative" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate the derivative of 1/(reward rate) with respect to the threshold (<strong>output</strong> arg)
and drift_rate (<strong>input</strong> arg).  Reward rate (RR) is assumed to be:</p>
<blockquote>
<div>RR = (delay<sub>ITI</sub> + Z/A + ED);</div></blockquote>
<p>the derivative of 1/RR with respect to the <a class="reference internal" href="#Function.BogaczEtAl.threshold" title="Function.BogaczEtAl.threshold"><code class="xref any py py-attr docutils literal"><span class="pre">threshold</span></code></a> is:</p>
<blockquote>
<div>1/A - E/A - (2A/c<sup>2</sup>)ED;</div></blockquote>
<p>and the derivative of 1/RR with respect to the <a class="reference internal" href="#Function.BogaczEtAl.drift_rate" title="Function.BogaczEtAl.drift_rate"><code class="xref any py py-attr docutils literal"><span class="pre">drift_rate</span></code></a> is:</p>
<blockquote>
<div>-Z/A<sup>2</sup> + (Z/A<sup>2</sup>)E - (2Z/c<sup>2</sup>)ED</div></blockquote>
<p>where:</p>
<blockquote>
<div><p>A = <a class="reference internal" href="#Function.BogaczEtAl.drift_rate" title="Function.BogaczEtAl.drift_rate"><code class="xref any py py-attr docutils literal"><span class="pre">drift_rate</span></code></a>,</p>
<p>Z = <a class="reference internal" href="#Function.BogaczEtAl.threshold" title="Function.BogaczEtAl.threshold"><code class="xref any py py-attr docutils literal"><span class="pre">threshold</span></code></a>,</p>
<p>c = <a class="reference internal" href="#Function.BogaczEtAl.noise" title="Function.BogaczEtAl.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a>,</p>
<p>E = exp(-2ZA/c<sup>2</sup>), and</p>
<p>D = delay<sub>ITI</sub> + delay<sub>penalty</sub> - Z/A</p>
<p>delay<sub>ITI</sub> is the intertrial interval and delay<sub>penalty</sub> is a penalty delay.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>derivatives</strong> â of 1/RR with respect to <a class="reference internal" href="#Function.BogaczEtAl.threshold" title="Function.BogaczEtAl.threshold"><code class="xref any py py-attr docutils literal"><span class="pre">threshold</span></code></a> and <a class="reference internal" href="#Function.BogaczEtAl.drift_rate" title="Function.BogaczEtAl.drift_rate"><code class="xref any py py-attr docutils literal"><span class="pre">drift_rate</span></code></a>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">List[float, float)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.NavarroAndFuss">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">NavarroAndFuss</code><span class="sig-paren">(</span><em>default_variable=ClassDefaults.variable</em>, <em>drift_rate=1.0</em>, <em>threshold=1.0</em>, <em>starting_point=0.0</em>, <em>t0=0.2                                          noise=0.5</em>, <em>params=None</em>, <em>owner=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.NavarroAndFuss" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="navarroandfuss">Return terminal value of decision variable, mean accuracy, mean response time (RT), correct RT mean, correct RT
variance and correct RT skew computed analytically for the drift diffusion process (Wiener diffusion model)
as described in <a class="reference external" href="http://www.sciencedirect.com/science/article/pii/S0022249609000200">Navarro and Fuss (2009)</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Use of this Function requires that the MatLab engine is installed.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>default_variable</strong> (<em>number</em><em>, </em><em>list</em><em> or </em><em>np.array : default ClassDefaults.variable</em>) â specifies a template for decision variable(s);  if it is list or array, a separate solution is computed
independently for each element.</li>
<li><strong>drift_rate</strong> (<em>float</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 1.0</em>) â specifies the drift_rate of the drift diffusion process.  If it is a list or array,
it must be the same length as <code class="xref any docutils literal"><span class="pre">default_variable</span></code>.</li>
<li><strong>threshold</strong> (<em>float</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 1.0</em>) â specifies the threshold (boundary) of the drift diffusion process.  If it is a list or array,
it must be the same length as <code class="xref any docutils literal"><span class="pre">default_variable</span></code>.</li>
<li><strong>starting_point</strong> (<em>float</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 1.0</em>) â specifies the initial value of the decision variable for the drift diffusion process.  If it is a list or
array, it must be the same length as <code class="xref any docutils literal"><span class="pre">default_variable</span></code>.</li>
<li><strong>noise</strong> (<em>float</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 0.0</em>) â specifies the noise term (corresponding to the diffusion component) of the drift diffusion process.
If it is a float, it must be a number from 0 to 1.  If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">default_variable</span></code> and all elements must be floats from 0 to 1.</li>
<li><strong>t0</strong> (<em>float</em><em>, </em><em>list</em><em> or </em><em>1d np.array : default 0.2</em>) â specifies the non-decision time for solution. If it is a float, it must be a number from 0 to 1.  If it is a
list or array, it must be the same length as  <code class="xref any docutils literal"><span class="pre">default_variable</span></code> and all
elements must be floats from 0 to 1.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.NavarroAndFuss.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.NavarroAndFuss.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>number or 1d np.array</em> â holds initial value assigned to <code class="xref std std-keyword docutils literal"><span class="pre">default_variable</span></code> argument;
ignored by <code class="xref any docutils literal"><span class="pre">function</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.NavarroAndFuss.drift_rate">
<code class="descname">drift_rate</code><a class="headerlink" href="#Function.NavarroAndFuss.drift_rate" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float or 1d np.array</em> â determines the drift component of the drift diffusion process.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.NavarroAndFuss.threshold">
<code class="descname">threshold</code><a class="headerlink" href="#Function.NavarroAndFuss.threshold" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float or 1d np.array</em> â determines the threshold (bound) of the drift diffusion process (i.e., at which the integration
process is assumed to terminate).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.NavarroAndFuss.starting_point">
<code class="descname">starting_point</code><a class="headerlink" href="#Function.NavarroAndFuss.starting_point" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float or 1d np.array</em> â determines the initial value of the decision variable for the drift diffusion process.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.NavarroAndFuss.noise">
<code class="descname">noise</code><a class="headerlink" href="#Function.NavarroAndFuss.noise" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float or 1d np.array</em> â determines the diffusion component of the drift diffusion process (used to specify the variance of a
Gaussian random process).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.NavarroAndFuss.t0">
<code class="descname">t0</code><a class="headerlink" href="#Function.NavarroAndFuss.t0" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float or 1d np.array</em> â determines the assumed non-decision time to determine the response time returned by the solution.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.NavarroAndFuss.bias">
<code class="descname">bias</code><a class="headerlink" href="#Function.NavarroAndFuss.bias" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float or 1d np.array</em> â normalized starting point:
(<a class="reference internal" href="#Function.BogaczEtAl.starting_point" title="Function.BogaczEtAl.starting_point"><code class="xref any py py-attr docutils literal"><span class="pre">starting_point</span></code></a> + <a class="reference internal" href="#Function.BogaczEtAl.threshold" title="Function.BogaczEtAl.threshold"><code class="xref any py py-attr docutils literal"><span class="pre">threshold</span></code></a>) /
(2 * <a class="reference internal" href="#Function.BogaczEtAl.threshold" title="Function.BogaczEtAl.threshold"><code class="xref any py py-attr docutils literal"><span class="pre">threshold</span></code></a>)</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.NavarroAndFuss.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.NavarroAndFuss.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Mechanism</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.NavarroAndFuss.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.NavarroAndFuss.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.NavarroAndFuss.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 2&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.NavarroAndFuss.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return: terminal value of decision variable, mean accuracy (error rate; ER), mean response time (RT),
correct RT mean, correct RT variance and correct RT skew.  <strong>Requires that the MatLab engine is installed.</strong></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>2d np.array</em>) â ignored.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) â specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Decision variable, mean ER, mean RT, correct RT mean, correct RT variance, correct RT skew</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">(float, float, float, float, float, float)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.NormalDist">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">NormalDist</code><span class="sig-paren">(</span><em>mean=0.0</em>, <em>standard_dev=1.0</em>, <em>params=None</em>, <em>owner=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.NormalDist" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="normaldist">Return a random sample from a normal distribution using numpy.random.normal</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mean</strong> (<em>float : default 0.0</em>) â The mean or center of the normal distribution</li>
<li><strong>standard_dev</strong> (<em>float : default 1.0</em>) â Standard deviation of the normal distribution</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.NormalDist.mean">
<code class="descname">mean</code><a class="headerlink" href="#Function.NormalDist.mean" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 0.0</em> â The mean or center of the normal distribution</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.NormalDist.standard_dev">
<code class="descname">standard_dev</code><a class="headerlink" href="#Function.NormalDist.standard_dev" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 1.0</em> â Standard deviation of the normal distribution</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.NormalDist.params">
<code class="descname">params</code><a class="headerlink" href="#Function.NormalDist.params" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Optional[Dict[param keyword, param value]]</em> â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.NormalDist.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.NormalDist.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Component</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.NormalDist.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.NormalDist.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Optional[PreferenceSet or specification dict : Function.classPreferences]</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.ExponentialDist">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">ExponentialDist</code><span class="sig-paren">(</span><em>beta=1.0</em>, <em>params=None</em>, <em>owner=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.ExponentialDist" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="exponentialdist">Return a random sample from a exponential distribution using numpy.random.exponential</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>beta</strong> (<em>float : default 1.0</em>) â The scale parameter of the exponential distribution</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.ExponentialDist.beta">
<code class="descname">beta</code><a class="headerlink" href="#Function.ExponentialDist.beta" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 1.0</em> â The scale parameter of the exponential distribution</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.ExponentialDist.params">
<code class="descname">params</code><a class="headerlink" href="#Function.ExponentialDist.params" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Optional[Dict[param keyword, param value]]</em> â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.ExponentialDist.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.ExponentialDist.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Component</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.ExponentialDist.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.ExponentialDist.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Optional[PreferenceSet or specification dict : Function.classPreferences]</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.UniformDist">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">UniformDist</code><span class="sig-paren">(</span><em>low=0.0</em>, <em>high=1.0</em>, <em>params=None</em>, <em>owner=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.UniformDist" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="uniformdist">Return a random sample from a uniform distribution using numpy.random.uniform</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>low</strong> (<em>float : default 0.0</em>) â Lower bound of the uniform distribution</li>
<li><strong>high</strong> (<em>float : default 1.0</em>) â Upper bound of the uniform distribution</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.UniformDist.low">
<code class="descname">low</code><a class="headerlink" href="#Function.UniformDist.low" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 0.0</em> â Lower bound of the uniform distribution</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.UniformDist.high">
<code class="descname">high</code><a class="headerlink" href="#Function.UniformDist.high" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 1.0</em> â Upper bound of the uniform distribution</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.UniformDist.params">
<code class="descname">params</code><a class="headerlink" href="#Function.UniformDist.params" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Optional[Dict[param keyword, param value]]</em> â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.UniformDist.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.UniformDist.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Component</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.UniformDist.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.UniformDist.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Optional[PreferenceSet or specification dict : Function.classPreferences]</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.GammaDist">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">GammaDist</code><span class="sig-paren">(</span><em>scale=1.0</em>, <em>dist_shape=1.0</em>, <em>params=None</em>, <em>owner=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.GammaDist" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="gammadist">Return a random sample from a gamma distribution using numpy.random.gamma</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>scale</strong> (<em>float : default 1.0</em>) â The scale of the gamma distribution. Should be greater than zero.</li>
<li><strong>dist_shape</strong> (<em>float : default 1.0</em>) â The shape of the gamma distribution. Should be greater than zero.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.GammaDist.scale">
<code class="descname">scale</code><a class="headerlink" href="#Function.GammaDist.scale" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 1.0</em> â The dist_shape of the gamma distribution. Should be greater than zero.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.GammaDist.dist_shape">
<code class="descname">dist_shape</code><a class="headerlink" href="#Function.GammaDist.dist_shape" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 1.0</em> â The scale of the gamma distribution. Should be greater than zero.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.GammaDist.params">
<code class="descname">params</code><a class="headerlink" href="#Function.GammaDist.params" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Optional[Dict[param keyword, param value]]</em> â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.GammaDist.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.GammaDist.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Component</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.GammaDist.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.GammaDist.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Optional[PreferenceSet or specification dict : Function.classPreferences]</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.WaldDist">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">WaldDist</code><span class="sig-paren">(</span><em>scale=1.0</em>, <em>mean=1.0</em>, <em>params=None</em>, <em>owner=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.WaldDist" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="walddist">Return a random sample from a Wald distribution using numpy.random.wald</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>scale</strong> (<em>float : default 1.0</em>) â Scale parameter of the Wald distribution. Should be greater than zero.</li>
<li><strong>mean</strong> (<em>float : default 1.0</em>) â Mean of the Wald distribution. Should be greater than or equal to zero.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.WaldDist.scale">
<code class="descname">scale</code><a class="headerlink" href="#Function.WaldDist.scale" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 1.0</em> â Scale parameter of the Wald distribution. Should be greater than zero.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.WaldDist.mean">
<code class="descname">mean</code><a class="headerlink" href="#Function.WaldDist.mean" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float : default 1.0</em> â Mean of the Wald distribution. Should be greater than or equal to zero.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.WaldDist.params">
<code class="descname">params</code><a class="headerlink" href="#Function.WaldDist.params" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Optional[Dict[param keyword, param value]]</em> â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.WaldDist.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.WaldDist.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Component</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.WaldDist.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.WaldDist.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Optional[PreferenceSet or specification dict : Function.classPreferences]</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.Stability">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Stability</code><span class="sig-paren">(</span><em>default_variable=ClassDefaults.variable</em>, <em>matrix=HOLLOW_MATRIX</em>, <em>metric=ENERGY                                   transfer_fct=None                               normalize=False</em>, <em>params=None</em>, <em>owner=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Stability" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="stability">Return the stability of a vector based an a weight matrix from each element to every other element in the vector.
The value of <a class="reference internal" href="#Function.Stability.variable" title="Function.Stability.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> is passed through the <a class="reference internal" href="#Function.Stability.matrix" title="Function.Stability.matrix"><code class="xref any py py-attr docutils literal"><span class="pre">matrix</span></code></a>, transformed
using the <a class="reference internal" href="#Function.Stability.transfer_fct" title="Function.Stability.transfer_fct"><code class="xref any py py-attr docutils literal"><span class="pre">transfer_fct</span></code></a> (if specified), and then compared with its initial value
using the specified <a class="reference internal" href="#Function.Stability.metric" title="Function.Stability.metric"><code class="xref any py py-attr docutils literal"><span class="pre">metric</span></code></a>.  If <a class="reference internal" href="#Function.Stability.normalize" title="Function.Stability.normalize"><code class="xref any py py-attr docutils literal"><span class="pre">normalize</span></code></a> is specified, the result
is normalized by the number of elements in the <a class="reference internal" href="#Function.Stability.variable" title="Function.Stability.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>list of numbers</em><em> or </em><em>1d np.array : Default ClassDefaults.variable</em>) â the array for which stabilty is calculated.</li>
<li><strong>matrix</strong> (<em>list</em><em>, </em><em>np.ndarray</em><em>, </em><em>np.matrix</em><em>, </em><em>function keyword</em><em>, or </em><em>MappingProjection : default HOLLOW_MATRIX</em>) â specifies the matrix of recurrent weights;  must be a square matrix with the same width as the
length of <a class="reference internal" href="#Function.Stability.variable" title="Function.Stability.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</li>
<li><strong>metric</strong> (<em>ENERGY</em><em>, </em><em>ENTROPY</em><em> or </em><em>keyword in DISTANCE_METRICS : Default ENERGY</em>) â specifies the metric used to compute stability.</li>
<li><strong>transfer_fct</strong> (<a class="reference internal" href="#Function.AccumulatorIntegrator.function" title="Function.AccumulatorIntegrator.function"><em>function</em></a><em> or </em><em>method : Default None</em>) â specifies the function used to transform output of weight <a class="reference internal" href="#Function.Stability.matrix" title="Function.Stability.matrix"><code class="xref any py py-attr docutils literal"><span class="pre">matrix</span></code></a>.</li>
<li><strong>normalize</strong> (<em>bool : Default False</em>) â specifies whether to normalize the stability value by the length of <a class="reference internal" href="#Function.Stability.variable" title="Function.Stability.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.Stability.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.Stability.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d np.array</em> â array for which stability is calculated.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Stability.matrix">
<code class="descname">matrix</code><a class="headerlink" href="#Function.Stability.matrix" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>list, np.ndarray, np.matrix, function keyword, or MappingProjection : default HOLLOW_MATRIX</em> â weight matrix from each element of <code class="xref any docutils literal"><span class="pre">variable</span></code> to each other;  if a matrix other
than HOLLOW_MATRIX is assigned, it is convolved with HOLLOW_MATRIX to eliminate self-connections from the
stability calculation.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Stability.metric">
<code class="descname">metric</code><a class="headerlink" href="#Function.Stability.metric" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>ENERGY, ENTROPY or keyword in DISTANCE_METRICS</em> â metric used to compute stability.  If ENTROPY or DISTANCE_METRICS keyword is used, the <a class="reference internal" href="#Function.Distance" title="Function.Distance"><code class="xref any py py-class docutils literal"><span class="pre">Distance</span></code></a> Function
is used to compute the stability of <a class="reference internal" href="#Function.Stability.variable" title="Function.Stability.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> with respect to its value after
transformation by <a class="reference internal" href="#Function.Stability.matrix" title="Function.Stability.matrix"><code class="xref any py py-attr docutils literal"><span class="pre">matrix</span></code></a> and <a class="reference internal" href="#Function.Stability.transfer_fct" title="Function.Stability.transfer_fct"><code class="xref any py py-attr docutils literal"><span class="pre">transfer_fct</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Stability.transfer_fct">
<code class="descname">transfer_fct</code><a class="headerlink" href="#Function.Stability.transfer_fct" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>function or method</em> â function used to transform output of weight <a class="reference internal" href="#Function.Stability.matrix" title="Function.Stability.matrix"><code class="xref any py py-attr docutils literal"><span class="pre">matrix</span></code></a> prior to computing stability.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Stability.normalize">
<code class="descname">normalize</code><a class="headerlink" href="#Function.Stability.normalize" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>bool</em> â if <code class="xref any docutils literal"><span class="pre">True</span></code>, result of stability calculation is normalized by the length of <a class="reference internal" href="#Function.Stability.variable" title="Function.Stability.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Stability.params">
<code class="descname">params</code><a class="headerlink" href="#Function.Stability.params" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Optional[Dict[param keyword, param value]]</em> â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Stability.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.Stability.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Component</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Stability.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.Stability.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Optional[PreferenceSet or specification dict : Function.classPreferences]</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.Stability.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 2&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Stability.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate the stability of <a class="reference internal" href="#Function.Stability.variable" title="Function.Stability.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</p>
<p>Compare the value of <a class="reference internal" href="#Function.Stability.variable" title="Function.Stability.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> with its value after transformation by
<a class="reference internal" href="#Function.Stability.matrix" title="Function.Stability.matrix"><code class="xref any py py-attr docutils literal"><span class="pre">matrix</span></code></a> and <a class="reference internal" href="#Function.Stability.transfer_fct" title="Function.Stability.transfer_fct"><code class="xref any py py-attr docutils literal"><span class="pre">transfer_fct</span></code></a> (if specified), using the specified
<a class="reference internal" href="#Function.Stability.metric" title="Function.Stability.metric"><code class="xref any py py-attr docutils literal"><span class="pre">metric</span></code></a>.  If <a class="reference internal" href="#Function.Stability.normalize" title="Function.Stability.normalize"><code class="xref any py py-attr docutils literal"><span class="pre">normalize</span></code></a> is <code class="xref any docutils literal"><span class="pre">True</span></code>, the result is divided
by the length of <a class="reference internal" href="#Function.Stability.variable" title="Function.Stability.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>stability</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">scalar</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.Distance">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Distance</code><span class="sig-paren">(</span><em>default_variable=ClassDefaults.variable</em>, <em>metric=EUCLIDEAN                               normalize=False</em>, <em>params=None</em>, <em>owner=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Distance" title="Permalink to this definition">Â¶</a></dt>
<dd><p id="distance">Return the distance between two vectors based on a specified metric.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>2d np.array with two items : Default ClassDefaults.variable</em>) â the arrays between which the distance is calculated.</li>
<li><strong>metric</strong> (<em>keyword in DISTANCE_METRICS : Default EUCLIDEAN</em>) â specifies the metric used to compute the distance between the two items in <a class="reference internal" href="#Function.Distance.variable" title="Function.Distance.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</li>
<li><strong>normalize</strong> (<em>bool : Default False</em>) â specifies whether to normalize the distance by the length of <a class="reference internal" href="#Function.Distance.variable" title="Function.Distance.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.Distance.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.Distance.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>2d np.array with two items</em> â contains the arrays between which the distance is calculated.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Distance.metric">
<code class="descname">metric</code><a class="headerlink" href="#Function.Distance.metric" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>keyword in DISTANCE_METRICS</em> â specifies the metric used to compute the distance between the two items in <a class="reference internal" href="#Function.Distance.variable" title="Function.Distance.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Distance.normalize">
<code class="descname">normalize</code><a class="headerlink" href="#Function.Distance.normalize" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>bool</em> â specifies whether to normalize the distance by the length of <a class="reference internal" href="#Function.Distance.variable" title="Function.Distance.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Distance.params">
<code class="descname">params</code><a class="headerlink" href="#Function.Distance.params" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Optional[Dict[param keyword, param value]]</em> â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Distance.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.Distance.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Component</em> â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Distance.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.Distance.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Optional[PreferenceSet or specification dict : Function.classPreferences]</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.Distance.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 2&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Distance.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate the distance between the two arrays in <a class="reference internal" href="#Function.Stability.variable" title="Function.Stability.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>distance</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">scalar</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.LearningFunction">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">LearningFunction</code><span class="sig-paren">(</span><em>default_variable</em>, <em>params</em>, <em>owner=None</em>, <em>name=None</em>, <em>prefs=None</em>, <em>context='Function_Base Init'</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LearningFunction" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Abstract class of <a class="reference internal" href="#"><span class="doc">Functions</span></a> used for learning.</p>
<p>All LearningFunctions take three input values (specified in each of the three required items of the
<a class="reference internal" href="#Function.AccumulatorIntegrator.variable" title="Function.AccumulatorIntegrator.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> argument), and return two output values.</p>
<dl class="docutils">
<dt>Input values:</dt>
<dd><ul class="first last simple">
<li>input to the parameter being modified (variable[0]);</li>
<li>output of the parameter being modified (variable[1]);</li>
<li>error associated with the output (variable[2]).</li>
</ul>
</dd>
<dt>Output values:</dt>
<dd><ul class="first last simple">
<li>learning_signal: modifications calculated by the function that attempt to reduce the error;</li>
<li>error_signal: the error received, possibly modified by the function.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="Function.Reinforcement">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Reinforcement</code><span class="sig-paren">(</span><em>default_variable=ClassDefaults.variable</em>, <em>activation_function=SoftMax</em>, <em>learning_rate=None</em>, <em>params=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Reinforcement" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Implements a function that calculates a diagonal matrix of weight changes using the reinforcement (delta)
learning rule.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>List</em><em> or </em><em>2d np.array</em><em> [</em><em>length 3</em><em>] </em><em>: default ClassDefaults.variable</em>) â template for the three items provided as the variable in the call to the <a class="reference internal" href="#Function.Reinforcement.function" title="Function.Reinforcement.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a>
(in order):
<a class="reference internal" href="#Function.Reinforcement.activation_input" title="Function.Reinforcement.activation_input"><code class="xref any py py-attr docutils literal"><span class="pre">activation_input</span></code></a> (1d np.array),
<a class="reference internal" href="#Function.Reinforcement.activation_output" title="Function.Reinforcement.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a> (1d np.array),
<a class="reference internal" href="#Function.Reinforcement.error_signal" title="Function.Reinforcement.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a> (1d np.array).</li>
<li><strong>activation_function</strong> (<a class="reference internal" href="#module-Function" title="Function"><em>Function</em></a><em> or </em><em>function : SoftMax</em>) â specifies the function of the Mechanism that generates <a class="reference internal" href="#Function.Reinforcement.activation_output" title="Function.Reinforcement.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a>.</li>
<li><strong>learning_rate</strong> (<em>float : default default_learning_rate</em>) â supersedes any specification for the <a class="reference internal" href="Process.html"><span class="doc">Process</span></a> and/or <a class="reference internal" href="System.html"><span class="doc">System</span></a> to which the functionâs
<code class="xref any docutils literal"><span class="pre">owner</span></code> belongs (see <a class="reference internal" href="#Function.Reinforcement.learning_rate" title="Function.Reinforcement.learning_rate"><code class="xref any py py-attr docutils literal"><span class="pre">learning_rate</span></code></a> for details).</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.Reinforcement.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.Reinforcement.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>2d np.array</em> â  specifies three values used as input to the <a class="reference internal" href="#Function.Reinforcement.function" title="Function.Reinforcement.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a>:
<a class="reference internal" href="#Function.Reinforcement.activation_input" title="Function.Reinforcement.activation_input"><code class="xref any py py-attr docutils literal"><span class="pre">activation_input</span></code></a>,
<a class="reference internal" href="#Function.Reinforcement.activation_output" title="Function.Reinforcement.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a>, and
<a class="reference internal" href="#Function.Reinforcement.error_signal" title="Function.Reinforcement.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reinforcement.activation_input">
<code class="descname">activation_input</code><a class="headerlink" href="#Function.Reinforcement.activation_input" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d np.array</em> â first item of <a class="reference internal" href="#Function.Reinforcement.variable" title="Function.Reinforcement.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>;  this is not used (it is implemented for consistency
with other <a class="reference internal" href="#Function.LearningFunction" title="Function.LearningFunction"><code class="xref any py py-class docutils literal"><span class="pre">LearningFunctions</span></code></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reinforcement.activation_output">
<code class="descname">activation_output</code><a class="headerlink" href="#Function.Reinforcement.activation_output" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d np.array</em> â the output of the function for which the matrix being modified provides the input; must have a single non-zero
value (corresponding to the selected âactionâ).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reinforcement.error_signal">
<code class="descname">error_signal</code><a class="headerlink" href="#Function.Reinforcement.error_signal" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d np.array</em> â the error signal associated with the <a class="reference internal" href="#Function.Reinforcement.activation_output" title="Function.Reinforcement.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a>; must be the same
length as <a class="reference internal" href="#Function.Reinforcement.activation_output" title="Function.Reinforcement.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a> and must have a single non-zero value in the
same position as the one in <a class="reference internal" href="#Function.Reinforcement.activation_output" title="Function.Reinforcement.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reinforcement.activation_function">
<code class="descname">activation_function</code><a class="headerlink" href="#Function.Reinforcement.activation_function" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Function or function : SoftMax</em> â the function of the Mechanism that generates <a class="reference internal" href="#Function.Reinforcement.activation_output" title="Function.Reinforcement.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a>; must
return and array with a single non-zero value.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reinforcement.learning_rate">
<code class="descname">learning_rate</code><a class="headerlink" href="#Function.Reinforcement.learning_rate" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float</em> â the learning rate used by the function.  If specified, it supersedes any learning_rate specified for the
<code class="xref any docutils literal"><span class="pre">Process</span></code> and/or <a class="reference internal" href="System.html#system-learning"><span class="std std-ref">System</span></a> to which the functionâs
<a class="reference internal" href="#Function.Reinforcement.owner" title="Function.Reinforcement.owner"><code class="xref any py py-attr docutils literal"><span class="pre">owner</span></code></a> belongs.  If it is <code class="xref any docutils literal"><span class="pre">None</span></code>, then the <a class="reference internal" href="Process.html#Process.Process_Base.learning_rate" title="Process.Process_Base.learning_rate"><code class="xref any py py-attr docutils literal"><span class="pre">learning_rate</span></code></a>
specified for the Process to which the <a class="reference internal" href="#Function.Reinforcement.owner" title="Function.Reinforcement.owner"><code class="xref any py py-attr docutils literal"><span class="pre">owner</span></code></a> belongs is used;  and, if that is <code class="xref any docutils literal"><span class="pre">None</span></code>,
then the <a class="reference internal" href="System.html#System.System_Base.learning_rate" title="System.System_Base.learning_rate"><code class="xref any py py-attr docutils literal"><span class="pre">learning_rate</span></code></a> for the System to which it belongs is used. If all are
<code class="xref any docutils literal"><span class="pre">None</span></code>, then the <a class="reference internal" href="#Function.Reinforcement.default_learning_rate" title="Function.Reinforcement.default_learning_rate"><code class="xref any py py-attr docutils literal"><span class="pre">default_learning_rate</span></code></a> is used.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reinforcement.default_learning_rate">
<code class="descname">default_learning_rate</code><a class="headerlink" href="#Function.Reinforcement.default_learning_rate" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float</em> â the value used for the <a class="reference internal" href="#Function.Reinforcement.learning_rate" title="Function.Reinforcement.learning_rate"><code class="xref any py py-attr docutils literal"><span class="pre">learning_rate</span></code></a> if it is not otherwise specified.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reinforcement.function">
<code class="descname">function</code><a class="headerlink" href="#Function.Reinforcement.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>function</em> â the function that computes the weight change matrix, and returns that along with the
<a class="reference internal" href="#Function.Reinforcement.error_signal" title="Function.Reinforcement.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a> received.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reinforcement.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.Reinforcement.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Mechanism</em> â <a class="reference internal" href="Mechanism.html"><span class="doc">Mechanism</span></a> to which the function belongs.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reinforcement.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.Reinforcement.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 2&gt;</em>, <em>context=None</em><span class="sig-paren">)</span></dt>
<dd><p>Calculate a matrix of weight changes from a single (scalar) error term</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>List</em><em> or </em><em>2d np.array</em><em> [</em><em>length 3</em><em>] </em><em>: default ClassDefaults.variable</em>) â must have three items that are the values for (in order):
<a class="reference internal" href="#Function.Reinforcement.activation_input" title="Function.Reinforcement.activation_input"><code class="xref any py py-attr docutils literal"><span class="pre">activation_input</span></code></a> (not used),
<a class="reference internal" href="#Function.Reinforcement.activation_output" title="Function.Reinforcement.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a> (1d np.array with a single non-zero value),
<a class="reference internal" href="#Function.Reinforcement.error_signal" title="Function.Reinforcement.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a> (1d np.array).</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) â specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>error signal</strong> (<em>1d np.array</em>) â same as value received in <a class="reference internal" href="#Function.Reinforcement.error_signal" title="Function.Reinforcement.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a> argument.</li>
<li><strong>diagonal weight change matrix</strong> (<em>2d np.array</em>) â has a single non-zero entry in the same row and column as the one in
<a class="reference internal" href="#Function.Reinforcement.activation_output" title="Function.Reinforcement.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a> and <a class="reference internal" href="#Function.Reinforcement.error_signal" title="Function.Reinforcement.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a>.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.BackPropagation">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">BackPropagation</code><span class="sig-paren">(</span><em>default_variable=ClassDefaults.variable</em>, <em>activation_derivative_fct=Logistic().derivative</em>, <em>error_derivative_fct=Logistic().derivative</em>, <em>error_matrix=None</em>, <em>learning_rate=None</em>, <em>params=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.BackPropagation" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Implements a function that calculate a matrix of weight changes using the backpropagation
(<a class="reference external" href="http://www.nature.com/nature/journal/v323/n6088/abs/323533a0.html">Generalized Delta Rule</a>) learning algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>List</em><em> or </em><em>2d np.array</em><em> [</em><em>length 3</em><em>] </em><em>: default ClassDefaults.variable</em>) â specifies a template for the three items provided as the variable in the call to the
<a class="reference internal" href="#Function.BackPropagation.function" title="Function.BackPropagation.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a> (in order):
<a class="reference internal" href="#Function.BackPropagation.activation_input" title="Function.BackPropagation.activation_input"><code class="xref any py py-attr docutils literal"><span class="pre">activation_input</span></code></a> (1d np.array),
<a class="reference internal" href="#Function.BackPropagation.activation_output" title="Function.BackPropagation.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a> (1d np.array),
<a class="reference internal" href="#Function.BackPropagation.error_signal" title="Function.BackPropagation.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a> (1d np.array).</li>
<li><strong>activation_derivative</strong> (<a class="reference internal" href="#module-Function" title="Function"><em>Function</em></a><em> or </em><a class="reference internal" href="#Function.AccumulatorIntegrator.function" title="Function.AccumulatorIntegrator.function"><em>function</em></a>) â specifies the derivative for the function of the Mechanism that generates
<a class="reference internal" href="#Function.BackPropagation.activation_output" title="Function.BackPropagation.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a>.</li>
<li><strong>error_derivative</strong> (<a class="reference internal" href="#module-Function" title="Function"><em>Function</em></a><em> or </em><a class="reference internal" href="#Function.AccumulatorIntegrator.function" title="Function.AccumulatorIntegrator.function"><em>function</em></a>) â specifies the derivative for the function of the Mechanism that is the receiver of the
<a class="reference internal" href="#Function.BackPropagation.error_matrix" title="Function.BackPropagation.error_matrix"><code class="xref any py py-attr docutils literal"><span class="pre">error_matrix</span></code></a>.</li>
<li><strong>error_matrix</strong> (<em>List</em><em>, </em><em>2d np.array</em><em>, </em><em>np.matrix</em><em>, </em><a class="reference internal" href="ParameterState.html#module-ParameterState" title="ParameterState"><em>ParameterState</em></a><em>, or </em><a class="reference internal" href="MappingProjection.html#PathwayProjections.MappingProjection.MappingProjection" title="PathwayProjections.MappingProjection.MappingProjection"><em>MappingProjection</em></a>) â matrix, the output of which is used to calculate the <a class="reference internal" href="#Function.BackPropagation.error_signal" title="Function.BackPropagation.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a>.
If it is specified as a ParameterState it must be one for the <a class="reference internal" href="MappingProjection.html#PathwayProjections.MappingProjection.MappingProjection.matrix" title="PathwayProjections.MappingProjection.MappingProjection.matrix"><code class="xref any py py-attr docutils literal"><span class="pre">matrix</span></code></a>
parameter of a <a class="reference internal" href="MappingProjection.html"><span class="doc">MappingProjection</span></a>;  if it is a MappingProjection, it must be one with a
MATRIX parameterState.</li>
<li><strong>learning_rate</strong> (<em>float : default default_learning_rate</em>) â supersedes any specification for the <a class="reference internal" href="Process.html"><span class="doc">Process</span></a> and/or <a class="reference internal" href="System.html"><span class="doc">System</span></a> to which the functionâs
<code class="xref any docutils literal"><span class="pre">owner</span></code> belongs (see <a class="reference internal" href="#Function.BackPropagation.learning_rate" title="Function.BackPropagation.learning_rate"><code class="xref any py py-attr docutils literal"><span class="pre">learning_rate</span></code></a> for details).</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<a class="reference internal" href="Component.html#module-Component" title="Component"><em>Component</em></a>) â <a class="reference internal" href="Component.html"><span class="doc">component</span></a> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional</em><em>[</em><em>PreferenceSet</em><em> or </em><em>specification dict : Function.classPreferences</em><em>]</em>) â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref std std-doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.BackPropagation.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.BackPropagation.variable" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>2d np.array</em> â  contains the three values used as input to the <a class="reference internal" href="#Function.BackPropagation.function" title="Function.BackPropagation.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a>:
<a class="reference internal" href="#Function.BackPropagation.activation_input" title="Function.BackPropagation.activation_input"><code class="xref any py py-attr docutils literal"><span class="pre">activation_input</span></code></a>,
<a class="reference internal" href="#Function.BackPropagation.activation_output" title="Function.BackPropagation.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a>, and
<a class="reference internal" href="#Function.BackPropagation.error_signal" title="Function.BackPropagation.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.activation_input">
<code class="descname">activation_input</code><a class="headerlink" href="#Function.BackPropagation.activation_input" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d np.array</em> â the input to the matrix being modified; same as 1st item of <a href="#id7"><span class="problematic" id="id8">`</span></a>variable &lt;BackPropagation.variable&gt;.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.activation_output">
<code class="descname">activation_output</code><a class="headerlink" href="#Function.BackPropagation.activation_output" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d np.array</em> â the output of the function for which the matrix being modified provides the input;
same as 2nd item of <a href="#id9"><span class="problematic" id="id10">`</span></a>variable &lt;BackPropagation.variable&gt;.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.error_signal">
<code class="descname">error_signal</code><a class="headerlink" href="#Function.BackPropagation.error_signal" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>1d np.array</em> â the error signal for the next matrix (layer above) in the learning sequence, or the error computed from the
target (training signal) and the output of the last Mechanism in the sequence;
same as 3rd item of <a href="#id11"><span class="problematic" id="id12">`</span></a>variable &lt;BackPropagation.variable&gt;.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.error_matrix">
<code class="descname">error_matrix</code><a class="headerlink" href="#Function.BackPropagation.error_matrix" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>2d np.array or ParameterState</em> â matrix, the output of which is used to calculate the <a class="reference internal" href="#Function.BackPropagation.error_signal" title="Function.BackPropagation.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a>;
if it is a <a class="reference internal" href="ParameterState.html"><span class="doc">ParameterState</span></a>, it refers to the MATRIX parameterState of the <a class="reference internal" href="MappingProjection.html"><span class="doc">MappingProjection</span></a> being learned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.learning_rate">
<code class="descname">learning_rate</code><a class="headerlink" href="#Function.BackPropagation.learning_rate" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float</em> â the learning rate used by the function.  If specified, it supersedes any learning_rate specified for the
<code class="xref any docutils literal"><span class="pre">process</span></code> and/or <code class="xref any docutils literal"><span class="pre">system</span></code> to which the functionâs  <a class="reference internal" href="#Function.BackPropagation.owner" title="Function.BackPropagation.owner"><code class="xref any py py-attr docutils literal"><span class="pre">owner</span></code></a> belongs.  If it is <code class="xref any docutils literal"><span class="pre">None</span></code>, then the learning_rate specified for the process to
which the <code class="xref any docutils literal"><span class="pre">owner</span></code> belongs is used;  and, if that is <code class="xref any docutils literal"><span class="pre">None</span></code>, then the learning_rate for
the system to which it belongs is used. If all are <code class="xref any docutils literal"><span class="pre">None</span></code>, then the
<a class="reference internal" href="#Function.BackPropagation.default_learning_rate" title="Function.BackPropagation.default_learning_rate"><code class="xref any py py-attr docutils literal"><span class="pre">default_learning_rate</span></code></a> is used.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.default_learning_rate">
<code class="descname">default_learning_rate</code><a class="headerlink" href="#Function.BackPropagation.default_learning_rate" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>float</em> â the value used for the <a class="reference internal" href="#Function.BackPropagation.learning_rate" title="Function.BackPropagation.learning_rate"><code class="xref any py py-attr docutils literal"><span class="pre">learning_rate</span></code></a> if it is not otherwise specified.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.function">
<code class="descname">function</code><a class="headerlink" href="#Function.BackPropagation.function" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>function</em> â the function that computes the weight change matrix, and returns that along with the
<a class="reference internal" href="#Function.BackPropagation.error_signal" title="Function.BackPropagation.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a> received, weighted by the contribution made by each element of
<a class="reference internal" href="#Function.BackPropagation.activation_output" title="Function.BackPropagation.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a> as a function of the
<a class="reference internal" href="#Function.BackPropagation.error_matrix" title="Function.BackPropagation.error_matrix"><code class="xref any py py-attr docutils literal"><span class="pre">error_matrix</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.BackPropagation.owner" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>Mechanism</em> â <a class="reference internal" href="Mechanism.html"><span class="doc">Mechanism</span></a> to which the function belongs.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.BackPropagation.prefs" title="Permalink to this definition">Â¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> â the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <strong>prefs</strong> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref std std-doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 2&gt;</em>, <em>context=None</em><span class="sig-paren">)</span></dt>
<dd><p>Calculate and return a matrix of weight changes from arrays of inputs, outputs and error terms</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>List</em><em> or </em><em>2d np.array</em><em> [</em><em>length 3</em><em>] </em><em>: default ClassDefaults.variable</em>) â must have three items that are the values for (in order):
<a class="reference internal" href="#Function.BackPropagation.activation_input" title="Function.BackPropagation.activation_input"><code class="xref any py py-attr docutils literal"><span class="pre">activation_input</span></code></a> (1d np.array),
<a class="reference internal" href="#Function.BackPropagation.activation_output" title="Function.BackPropagation.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a> (1d np.array),
<a class="reference internal" href="#Function.BackPropagation.error_signal" title="Function.BackPropagation.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a> (1d np.array).</li>
<li><strong>params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>param keyword</em><em>, </em><em>param value</em><em>]</em><em>]</em>) â a <a class="reference internal" href="ParameterState.html#parameterstate-specification"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) â specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>weighted error signal</strong> (<em>1d np.array</em>) â <a class="reference internal" href="#Function.BackPropagation.error_signal" title="Function.BackPropagation.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a>, weighted by the contribution made by each element of
<a class="reference internal" href="#Function.BackPropagation.activation_output" title="Function.BackPropagation.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a> as a function of
<a class="reference internal" href="#Function.BackPropagation.error_matrix" title="Function.BackPropagation.error_matrix"><code class="xref any py py-attr docutils literal"><span class="pre">error_matrix</span></code></a>.</li>
<li><strong>weight change matrix</strong> (<em>2d np.array</em>) â the modifications to make to the matrix.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Composition.html" class="btn btn-neutral float-right" title="Compositions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="GatingSignal.html" class="btn btn-neutral" title="GatingSignal" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Jonathan D. Cohen.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.3.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>