# Princeton University licenses this file to You under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.  You may obtain a copy of the License at:
#     http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
# on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.


# ********************************************  FunctionApproximator ***************************************************

"""

# FIX: SHOULD BE IMPLEMENTED AS ABSTRACT BASE CLASS (ABC)

Function Approximator
^^^^^^^^^^^^^^^^^^^^^

A `FunctionApproximator` is an abstract subclass of `Composition` that, over calls to its `adapt
<FunctionApproximator.adapt>` method, parameterizes it `function <Composition.function>` to predict the
`target <FunctionApproximator.target>` for a given `input <FunctionApproximator.input>`.  Its `evaluate
<FunctionApproximator.evaluate>` method calls its `function <FunctionApproximator.function>` to generate and return a
predicted `target <FunctionApproximator.target>` for a given `input <FunctionApproximator.input>`.


"""
import warnings
from collections import Iterable, deque
from itertools import product
import typecheck as tc
# from aenum import AutoNumberEnum, auto
from enum import Enum

import numpy as np

# from psyneulink.core.compositions.composition import Composition_Base

__all__ = ['FunctionApproximator']


class FunctionApproximatorError(Exception):
    def __init__(self, error_value):
        self.error_value = error_value


class FunctionApproximator():
    '''Parameterizes a `parameterization_function <FunctionApproximator.parameterization_function>` to predict a
    `target <FunctionApproximator.target>` from an `input <FunctionApproximator.input>`.

    '''
    def __init__(self,
                 function=None
                 ):
        '''

        Arguments
        ---------

        function : LearningFunction, function or method
            specifies the function used to generate and return a predicted `target <FunctionApproximator.target>` for a
            given `input <FunctionApproximator.input>`.

        Attributes
        ----------

        function : LearningFunction, function or method
            parameterized by `adapt <FunctionAppproximator.adapt>` method and used by `FunctionAppproximator.evaluate`
            method to predict `target <FunctionApproximator.target>` for a given `input<FunctionAppproximator.input>`.

        prediction_parameters : 1d array
            parameters adjusted by `adapt <FunctionApproximator.adapt>` method, and used by `function
            <FunctionAppproximator.function>` to predict `target <FunctionApproximator.target>` for a given `input
            <FunctionAppproximator.input>`.

        input : list or array
            value(s) provided to `adapt <FunctionAppproximator>` and `evaluate <FunctionAppproximator.evaluate>`
            methods to parameterize `function <FunctionAppproximator.function>` and generate a prediction, respectively.

        target : list or array
            value(s) provided to `adapt <FunctionAppproximator>` method to parameterize `function
            <FunctionAppproximator.function>`, and generated by `evaluate <FunctionAppproximator.evaluate>` method
            from a given `input <FunctionAppproximator.input>`.

        '''
        self.function = function

    def adapt(self, input, target, context=None):
        '''Adjust parameters of `function <FunctionAppproximator.function>` to improve prediction of `target
        <FunctionAppproximator.target>` from `input <FunctionAppproximator.input>`.'''
        raise FunctionApproximatorError("Subclass of {} ({}) must implement {} method.".
                                        format(FunctionApproximator.__name__, self.__class__.__name__, repr('adapt')))

    def evaluate(self, input, context=None):
        '''Return `target <FunctionAppproximator.target>` predicted by `function <FunctionAppproximator.function> for
        **input**, using current set of `prediction_parameters <FunctionAppproximator.prediction_parameters>`.
        '''
        self.target = self.function(input)
        return self.target

    @property
    def prediction_parameters(self):
        raise FunctionApproximatorError("Subclass of {} ({}) must implement {} attribute.".
                                        format(FunctionApproximator.__name__, self.__class__.__name__,
                                               repr('prediction_parameters')))
