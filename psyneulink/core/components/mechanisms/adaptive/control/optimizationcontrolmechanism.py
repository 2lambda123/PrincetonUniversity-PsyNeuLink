# Princeton University licenses this file to You under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.  You may obtain a copy of the License at:
#     http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
# on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.


# **************************************  OptimizationControlMechanism *************************************************


"""

`ModelFreeOptimizationControlMechanism`
`ModelBasedOptimizationControlMechanism`

Overview
--------

OptimizationControlMechanism is an abstract class for defining subclasses of `ControlMechanism <ControlMechanism>` that
use an `OptimizationFunction` to find an `control_allocation <ControlMechanism.control_allocation>` that maximizes the
Expected Value of Control (EVC) for a given state.  The `OptimizationFunction` uses the OptimizationControlMechanism's
`evaluation_function <OptimizationControlMechanism.evaluation_function>` to evaluate the EVC for samples of
`control_allocation <ControlMechanism.control_allocation>`, and retuns the one that yields the greatest EVC.

.. _OptimizationControlMechanism_EVC:

**Expected Value of Control**

All OptimizationControlMechanisms compute the `Expected Value of Control (EVC)
<https://www.ncbi.nlm.nih.gov/pubmed/23889930>`_ --  a cost-benefit analysis that weighs the `costs
<ControlMechanism.costs>` of the `control_signals <ControlMechanism.control_signals>` for a given `control_allocation
<ControlMechanism.control_allocation>` against the `outcome <ControlMechanism.outcome>` expected to result from that
policy.  The EVC for an `control_allocation <ControlMechanism.control_allocation>` is computed by the
OptimizationControlMechanism's `evaluation_function <OptimizationControlMechanism.evaluation_function>`, using some
combination of the `costs <ControlMechanism.costs>` associated with the `control_allocation
<ControlMechanism.control_allocation>` and the current state, depending on the particular subclass.  The table `below
<OptimizationControlMechanism_Examples>` lists different
types of OptimizationControlMechanisms, followed by a list of models that implement examples of these.

.. _OptimizationControlMechanism_Model_Free_Model_Based:

**Model-Free and Model-Based OptimizationControlMechanisms**

There are two classes of OptimizationControlMechanisms -- "model-free" (`ModelFreeOptimizationControlMechanism`) and
"model-based" (`ModelBasedOptimizationControlMechanism`).  In broad terms, the `model-free
<ModelFreeOptimizationControlMechanism>` class parameterizes a `FunctionApproximator` over the course of `trials
<trial>` to predict the EVC based on previously experienced combinations of input and `control_allocation
<ControlMechanism.control_allocation>` and, within a given trial, uses the FunctionApproximator's `make_prediction
<FunctionApproximator.make_prediction>` method to test `allocation_policies <ControlMechanism.control_allocation>`
and find the one that is predicted to yield the greatest EVC for the current (or expected) input.  In contrast,
the `model-based <ModelBasedOptimizationControlMechanism>` class finds the `control_allocation
<ControlMechanism.control_allocation>` that yields the greatest EVC by actually testing them within a trial,
using the `run_simuation <Composition.run_simulation>` method of its Composition (i.e., the one that it `controls
<Composition.controller>`) to evaluate the actual outcome generated by each


.. _OptimizationControlMechanism_Creation:

Creating an OptimizationControlMechanism
----------------------------------------

An OptimizationControlMechanism can be created in the same was as any `ControlMechanism <ControlMechanism>`.  The only
constraint is that an `OptimizationFunction` (or a function that has the same structure as one) must be specified as
the **function** argument of its constructor.  In addition, a `ModelFreeOptimizationControlMechanism`
must be assigned a `FunctionApproximator`, while a `ModelBasedOptimizationControlMechanism` must be assigned as the
`controller <Composition.controller>` of a `Composition`.

.. _OptimizationControlMechanism_Structure:

Structure
---------

An OptimizationControlMechanism has the same structure as a `ControlMechanism`, including a `Projection <Projection>`
to its *OUTCOME* InputState from its `objective_mechanism <ControlMechanism.objective_mechanism>`, and a
`function <OptimizationControlMechanism.function>` used to carry out the optimization process, both of which are
described below.

.. _OptimizationControlMechanism_ObjectiveMechanism:

ObjectiveMechanism
^^^^^^^^^^^^^^^^^^

Like any `ControlMechanism`, an OptimizationControlMechanism has an associated `objective_mechanism
<ControlMechanism.objective_mechanism>` that is used to evaluate the outcome of processing for a given trial and pass
the result to the OptimizationControlMechanism, which it places in its `outcome <OptimizationControlMechanism.outcome>`
attribute.  This is used by its `evaluation_function <OptimizationControlMechanism.evaluation_function>`, together with
the `costs <ControlMechanism.costs>` of its `control_signals <ControlMechanism.control_signals>`, to carry out the
`EVC <OptimizationControlMechanism_EVC>` calculation.

.. note::
    The `objective_mechanism is distinct from, and should not be confused with the OptimizationControlMechanism's
    `evaluation_function <OptimizationControlMechanism.evaluation_function>`, which as the `objective_function
    <OptimizationFunction.objective_function>` parameter of its `OptimizationFunction`.  The `objective_mechanism
    <OptimizationControlMechanism.objective_mechanism>` evaluates the outcome of processing without taking into
    account the `costs <ControlMechanism.costs>` of the OptimizationControlMechanism's `control_signals
    <ControlMechanism.control_signals>`, whereas the its `evaluation_function
    <ControlMechanismOptimizationControlMechanism.evaluation_function>` takes these into account in calculating the
    `EVC <OptimizationControlMechanism_EVC>`.


.. _OptimizationControlMechanism_Function:

*Function*
^^^^^^^^^^

The `function <OptimizationControlMechanism.function>` of an OptimizationControlMechanism is used to find the
control_allocation that yields the greatest `EVC <OptimizationControlMechanism_EVC>` for the current (or expected)
input  It is generally an `OptimizationFunction`, which in turn has `objective_function
<OptimizationFunction.objective_function>`, `search_function <OptimizationFunction.search_function>` and
`search_termination_function <OptimizationFunction.search_termination_function>` methods, as well as a `search_space
<OptimizationFunction.search_space>` attribute.  The `objective_function <OptimizationFunction.objective_function>`
is used to evaluate each `control_allocation <ControlMechanism.control_allocation>` sampled by the `search_function
`search_function <OptimizationFunction.search_function>` from the `search_space <OptimizationFunction.search_space>`
attribute until the `search_termination_function <OptimizationFunction.search_termination_function>` returns `True`.
A custom function can be assigned as the `function <OptimizationControlMechanism.function>` of an
OptimizationControlMechanism, however it must meet the following requirements:

.. _OptimizationControlMechanism_Custom_Funtion:

    - it must accept as its first argument and return as its result an array with the same shape as the
      OptimizationControlMechanism's `control_allocation <ControlMechanism.control_allocation>`.

    - it must implement a `reinitialize` method that accepts as keyword arguments **objective_function**,
      **search_function**, **search_termination_function**, and **search_space**, and implement attributes
      with corresponding names.


.. _OptimizationControlMechanism_Evaluation_Function:

*Evaluation Function*

The `evaluation_function <OptimizationControlMechanism.evaluation_function>` of an OptimizationControlMechanism is
determined by its subclass:  `ModelFreeOptimizationControlMechanisms <ModelFreeOptimizationControlMechanism>` use
the `make_prediction <FunctionApproximator.make_prediction>` method of the `FunctionApproximator` assigned as their
`function_approximator <ModelFreeOptimizationControlMechanism.function_approximator>` attribute.
`ModelBasedOptimizationControlMechanisms <ModelBasedOptimizationControlMechanism>` use the `run_simulation
<Composition.run_simulation>` method of the `Composition` for which the OptimizationControlMechanism is a `controller
<Composition.controller>` The `evaluation_function <OptimizationControlMechanism.evaluation_function>` of the
OptimizationControlMechanism is assigned to as the `objective_function <OptimizationFunction.objective_function>`
parameter of its `OptimizationFunction`.

.. _OptimizationControlMechanism_Search_Functions:

*Search Function, Search Space and Search Termination Function*

The OptimizationControlMechanism may also implement `search_function <OptimizationControlMechanism.search_function>`
and `search_termination_function <OptimizationControlMechanism.search_termination_function>` methods, as well as a
`control_allocation_search_space <OptimizationControlMechanism.control_allocation_search_space>` attribute, that will
be passed as parameters to the `OptimizationFunction` when it is constructed.  These can be specifying in the
constructor for an `OptimizationFunction` assigned as the **function** argument of the
OptimizationControlMechanism's constructor, as long as they are compatible with the requirements of
the OptimizationFunction and OptimizationControlMechanism.  If they are not specified, then defaults specified
either by the OptimizationControlMechanism or the OptimizationFunction are used.

.. _OptimizationControlMechanism_Execution:

Execution
---------

When an OptimizationControlMechanism executes, it calls its `function <OptimizationControlMechanism.function>` to
find the `control_allocation <ControlMechanism.control_allocation>` that yields the greatest `EVC
<OptimizationControlMechanism_EVC>`.  The way in which it searches for the best `control_allocation
<ControlMechanism.control_allocation>` is determined by the type of `OptimzationFunction` assigned to `function
<OptimizationControlMechanism.function>`, whereas the way that it evaluates each one is determined by the
OptimizationControlMechanism's `evalution_function <OptimizationControlMechanism.evaluation_function>`.  More
specifically, The `function <OptimizationControlMechanism.function>` selects a sample `control_allocation
<ControlMechanism.control_allocation>` (usually using `search_function <OptimizationControlMechanism.search_function>`
to select one from `control_allocation_search_space <OptimizationControlMechanism.control_allocation_search_space>`),
and evaluates the EVC for that `control_allocation <ControlMechanism.control_allocation>` using the
OptimizationControlMechanism's `evaluation_function <OptimizationControlMechanism.evaluation_function>`.
How that is done depends on the subclass of OptimizationControlMechanism:  The `ModelFreeOptimizationControlMechanism
class uses a `FunctionApproximator` to predict find the `control_allocation <ControlMechanism.control_allocation>` that
it predicts will yield the greatest EVC for the current (or expected) input. The
`ModelBasedOptimizationControlMechanism` class uses the Composition`s `run_simulation <Composition.run_simluation>`
method to execute the Composition with each `control_allocation` and determine the actual outcome for the current (or
expected) input.  In either case, the values of the `control_allocation <ControlMechanism.control_allocation>` that
yielded the greatest EVC are assigned as the `variables <ControlSignal.variable>` of the
OptimizationControlMechanism's `control_signals <ControlMechanism.control_signals>`.  These are used by the
`control_signals <ControlMechanism.control_signals>` to compute their `values <ControlSignal.value>`, which are used
by their `ControlProjections <ControlProjection>` to modulate the parameters they control.

.. _OptimizationControlMechanism_Examples:

Examples
--------

The table below lists `model-free <ModelFreeOptimizationControlMechanism>` and `model-based
<ModelBasedOptimizationControlMechanism` subclasses of OptimizationControlMechanisms.

.. table:: **Model-Free and Model-Based OptimizationControlMechanisms**

   +-------------------------+----------------------+----------------------+---------------------+---------------------+------------------------------+
   |                         |     *Model-Free*     |                           *Model-Based*                                                         |
   +-------------------------+----------------------+----------------------+---------------------+---------------------+------------------------------+
   |**Functions**            |`LVOCControlMechanism`| LVOMControlMechanism | MDPControlMechanism |`EVCControlMechanism`| ParameterEstimationMechanism |
   +-------------------------+----------------------+----------------------+---------------------+---------------------+------------------------------+
   |**learning_function**    |     `BayesGLM`       |        `pymc`        |    `BeliefUpdate`   |       *None*        |           `pymc`             |
   +-------------------------+----------------------+----------------------+---------------------+---------------------+------------------------------+
   |**function** *(primary)* |`GradientOptimization`|     `GridSearch`     |       `Sample`      |    `GridSearch`     |           `Sample`           |
   +-------------------------+----------------------+----------------------+---------------------+---------------------+------------------------------+
   |       *search_function* |  *follow_gradient*   |   *traverse_grid*    | *sample_from_dist*  |   *traverse_grid*   |      *sample_from_dist*      |
   +-------------------------+----------------------+----------------------+---------------------+---------------------+------------------------------+
   |    *objective_function* |    *compute_EVC*     |  *run_simulation*,   |  *run_simulation*,  |  *run_simulation*,  |    *run_simulation*,         |
   |                         |                      |  *compute_EVC*       |  *compute_EVC*      |  *compute_EVC*      |    *compute_likelihood*      |
   +-------------------------+----------------------+----------------------+---------------------+---------------------+------------------------------+
   |             *execution* | *iterate w/in trial* |  *once per trial*    | *iterate w/in trial*| *iterate w/in trial*|     *iterate w/in trial*     |
   +-------------------------+----------------------+----------------------+---------------------+---------------------+------------------------------+

The following models provide examples of implementing the OptimizationControlMechanisms in the table above:

`LVOCControlMechanism`\\:  `BustamanteStroopXORLVOCModel`
`EVCControlMechanism`\\:  `UmemotoTaskSwitchingEVCModel`




.. _OptimizationControlMechanism_Class_Reference:

Class Reference
---------------

"""
from collections import Iterable

import typecheck as tc

import numpy as np

from psyneulink.core.components.functions.function import \
    ModulationParam, _is_modulation_param, is_function_type, OBJECTIVE_FUNCTION, \
    SEARCH_SPACE, SEARCH_FUNCTION, SEARCH_TERMINATION_FUNCTION
from psyneulink.core.components.mechanisms.mechanism import Mechanism
from psyneulink.core.components.mechanisms.adaptive.control.controlmechanism import ControlMechanism
from psyneulink.core.components.mechanisms.processing.objectivemechanism import \
    ObjectiveMechanism, MONITORED_OUTPUT_STATES
from psyneulink.core.components.mechanisms.adaptive.control.functionapproximator import FunctionApproximator
from psyneulink.core.components.states.inputstate import InputState
from psyneulink.core.components.states.outputstate import OutputState

from psyneulink.core.components.states.parameterstate import ParameterState
from psyneulink.core.components.states.modulatorysignals.controlsignal import ControlSignalCosts, ControlSignal
from psyneulink.core.components.states.state import _parse_state_spec
from psyneulink.core.components.functions.function import Function
from psyneulink.core.globals.keywords import DEFAULT_VARIABLE, INTERNAL_ONLY, NAME, \
    OBJECTIVE_MECHANISM, OPTIMIZATION_CONTROL_MECHANISM, OUTCOME, PARAMS, PARAMETER_STATES, FUNCTION, VARIABLE
from psyneulink.core.globals.preferences.componentpreferenceset import is_pref_set
from psyneulink.core.globals.preferences.preferenceset import PreferenceLevel
from psyneulink.core.globals.utilities import is_iterable
from psyneulink.core.globals.context import ContextFlags
from psyneulink.core.globals.defaults import defaultControlAllocation

__all__ = [
    'OptimizationControlMechanism', 'OptimizationControlMechanismError',
    'AGENT_REP', 'FEATURE_PREDICTORS', 'SHADOW_EXTERNAL_INPUTS'
]

AGENT_REP = 'agent_rep'
FEATURE_PREDICTORS = 'feature_predictors'
SHADOW_EXTERNAL_INPUTS = 'SHADOW_EXTERNAL_INPUTS'


class OptimizationControlMechanismError(Exception):
    def __init__(self, error_value):
        self.error_value = error_value

    def __str__(self):
        return repr(self.error_value)

    
class OptimizationControlMechanism(ControlMechanism):
    """OptimizationControlMechanism(                       \
    agent_rep=None,                                        \
    feature_predictors=None,                               \
    feature_function=None,                                 \
    objective_mechanism=None,                              \
    learning_function=None,                                \
    evaluation_function=None,                              \
    search_function=None,                                  \
    search_termination_function=None,                      \
    search_space=None,                                     \
    function=None,                                         \
    control_signals=None,                                  \
    modulation=ModulationParam.MULTIPLICATIVE,             \
    params=None,                                           \
    name=None,                                             \
    prefs=None)

    Subclass of `ControlMechanism <ControlMechanism>` that adjusts its `ControlSignals <ControlSignal>` to optimize
    performance of the `Composition` to which it belongs

    .. note::
       OptimizationControlMechanism is an abstract class and should NEVER be instantiated by a call to its constructor.
       It should be instantiated using the constructor for a subclass.

    Arguments
    ---------

    objective_mechanism : ObjectiveMechanism or List[OutputState specification]
        specifies either an `ObjectiveMechanism` to use for the OptimizationControlMechanism, or a list of the 
        `OutputState <OutputState>`\\s it should monitor; if a list of `OutputState specifications
        <ObjectiveMechanism_Monitored_Output_States>` is used, a default ObjectiveMechanism is created and the list
        is passed to its **monitored_output_states** argument.

    evaluation_function : function or method
        specifies the function used to evaluate the `EVC <OptimizationControlMechanism_EVC>` for a given
        `control_allocation <ControlMechanism.control_allocation>`. It is assigned as the `objective_function
        <OptimizationFunction.objective_function>` parameter of `function  <OptimizationControlMechanism.function>`, 
        unless that is specified in the constructor for an  OptimizationFunction assigned to the **function** 
        argument of the OptimizationControlMechanism's constructor.  Often it is assigned directy to the 
        OptimizationControlMechanism's `compute_EVC <OptimizationControlMechanism.compute_EVC>` method;  in some 
        cases it may implement additional operations, but should always call `compute_EVC 
        <OptimizationControlMechanism.compute_EVC>`. A custom function can be assigned, but it must take as its 
        first argument an array with the same shape as the OptimizationControlMechanism's `control_allocation
        <ControlMechanism.control_allocation>`, and return the following four values: an array containing the
        `control_allocation <ControlMechanism.control_allocation>` that generated the optimal `EVC
        <OptimizationControlMechanism_EVC>`; an array containing that EVC value;  a list containing each
        `control_allocation <ControlMechanism.control_allocation>` sampled if `function
        <OptimizationControlMechanism.function>` has a `save_samples <OptimizationFunction.save_samples>` attribute 
        and it is `True`, otherwise it should return an empty list; and a list containing the EVC values for each 
        `control_allocation <ControlMechanism.control_allocation>` sampled if the function has a `save_values
        <OptimizationFunction.save_values>` attribute and it is `True`, otherwise it should return an empty list.

    search_function : function or method
        specifies the function assigned to `function <OptimizationControlMechanism.function>` as its 
        `search_function <OptimizationFunction.search_function>` parameter, unless that is specified in a 
        constructor for `function <OptimizationControlMechanism.function>`.  It must take as its arguments 
        an array with the same shape as `control_allocation <ControlMechanism.control_allocation>` and an integer
        (indicating the iteration of the `optimization process <OptimizationFunction_Process>`), and return 
        an array with the same shape as `control_allocation <ControlMechanism.control_allocation>`.

    search_termination_function : function or method
        specifies the function assigned to `function <OptimizationControlMechanism.function>` as its 
        `search_termination_function <OptimizationFunction.search_termination_function>` parameter, unless that is 
        specified in a constructor for `function <OptimizationControlMechanism.function>`.  It must take as its 
        arguments an array with the same shape as `control_allocation <ControlMechanism.control_allocation>` and two
        integers (the first representing the `EVC <OptimizationControlMechanism_EVC>` value for the current 
        `control_allocation <ControlMechanism.control_allocation>`, and the second the current iteration of the
        `optimization process <OptimizationFunction_Process>`;  it must return `True` or `False`.
        
    search_space : list or ndarray
        specifies the `search_space <OptimizationFunction.search_space>` parameter for `function 
        <OptimizationControlMechanism.function>`, unless that is specified in a constructor for `function 
        <OptimizationControlMechanism.function>`.  Each item must have the same shape as `control_allocation
        <ControlMechanism.control_allocation>`.
        
    function : OptimizationFunction, function or method
        specifies the function used to optimize the `control_allocation <ControlMechanism.control_allocation>`;
        must take as its sole argument an array with the same shape as `control_allocation
        <ControlMechanism.control_allocation>`, and return a similar array (see `Primary Function
        <OptimizationControlMechanism>` for additional details).

    params : Dict[param keyword: param value] : default None
        a `parameter dictionary <ParameterState_Specification>` that can be used to specify the parameters for the
        Mechanism, its `learning_function <OptimizationControlMechanism.learning_function>`, and/or a custom function and its parameters.  Values
        specified for parameters in the dictionary override any assigned to those parameters in arguments of the
        constructor.

    name : str : default see `name <OptimizationControlMechanism.name>`
        specifies the name of the OptimizationControlMechanism.

    prefs : PreferenceSet or specification dict : default Mechanism.classPreferences
        specifies the `PreferenceSet` for the OptimizationControlMechanism; see `prefs
        <OptimizationControlMechanism.prefs>` for details.

    Attributes
    ----------

    function : OptimizationFunction, function or method
        takes current `control_allocation <ControlMechanism.control_allocation>` (as initializer),
        uses its `search_function <OptimizationFunction.search_function>` to select samples of `control_allocation
        <ControlMechanism.control_allocation>` from its `search_space <OptimizationControlMechanism.search_space>`,
        evaluates these using its `evaluation_function <OptimizationControlMechanism.evaluation_function>`, and returns
        the one that yields the greatest `EVC <OptimizationControlMechanism_EVC>`  (see `Primary Function
        <OptimizationControlMechanism_Function>` for additional details).

    evaluation_function : function or method
        returns `EVC <OptimizationControlMechanism_EVC>` for either the `current_state
        <OptimizationControlMechanism.current_state>` (model-free OptimizationControlMechanism) or an
        `control_allocation <ControlMechanism.control_allocation>` (model-based); assigned as the `objective_function
        <OptimizationFunction.objective_function>` parameter of `function <OptimizationControlMechanism.function>`.
        
    search_function : function or method
        `search_function <OptimizationFunction.search_function>` assigned to `function 
        <OptimizationControlMechanism.function>`; used to select samples of `control_allocation
        <ControlMechanism.control_allocation>` to evaluate by `evaluation_function
        <OptimizationControlMechanism.evaluation_function>`.

    search_termination_function : function or method
        `search_termination_function <OptimizationFunction.search_termination_function>` assigned to
        `function <OptimizationControlMechanism.function>`;  determines when to terminate the 
        `optimization process <OptimizationFunction_Process>`.
        
    control_allocation_search_space : list or ndarray
        `search_space <OptimizationFunction.search_space>` assigned to `function 
        <OptimizationControlMechanism.function>`;  determines the samples of
        `control_allocation <ControlMechanism.control_allocation>` evaluated by the `evaluation_function
        <OptimizationControlMechanism.evaluation_function>`.

    saved_samples : list
        contains all values of `control_allocation <ControlMechanism.control_allocation>` sampled by `function
        <OptimizationControlMechanism.function>` if its `save_samples <OptimizationFunction.save_samples>` parameter
        is `True`;  otherwise list is empty.

    saved_values : list
        contains values of EVC associated with all samples of `control_allocation <ControlMechanism.control_allocation>`
         evaluated by by `function <OptimizationControlMechanism.function>` if its `save_values 
         <OptimizationFunction.save_samples>` parameter is `True`;  otherwise list is empty.

    name : str
        name of the OptimizationControlMechanism; if it is not specified in the **name** argument of the constructor, a
        default is assigned by MechanismRegistry (see `Naming` for conventions used for default and duplicate names).

    prefs : PreferenceSet or specification dict
        the `PreferenceSet` for the OptimizationControlMechanism; if it is not specified in the **prefs** argument of
        the constructor, a default is assigned using `classPreferences` defined in __init__.py (see :doc:`PreferenceSet
        <LINK>` for details).
    """

    componentType = OPTIMIZATION_CONTROL_MECHANISM
    # initMethod = INIT_FULL_EXECUTE_METHOD
    # initMethod = INIT_EXECUTE_METHOD_ONLY

    classPreferenceLevel = PreferenceLevel.SUBTYPE
    # classPreferenceLevel = PreferenceLevel.TYPE
    # Any preferences specified below will override those specified in TypeDefaultPreferences
    # Note: only need to specify setting;  level will be assigned to Type automatically
    # classPreferences = {
    #     kwPreferenceSetName: 'DefaultControlMechanismCustomClassPreferences',
    #     kp<pref>: <setting>...}

    # FIX: ADD OTHER Params() HERE??
    class Params(ControlMechanism.Params):
        function = None

    paramClassDefaults = ControlMechanism.paramClassDefaults.copy()
    paramClassDefaults.update({PARAMETER_STATES: NotImplemented}) # This suppresses parameterStates


    @tc.typecheck
    def __init__(self,
                 agent_rep=None,
                 feature_predictors:tc.optional(tc.any(Iterable, Mechanism, OutputState, InputState))=None,
                 feature_function:tc.optional(tc.any(is_function_type))=None,
                 objective_mechanism:tc.optional(tc.any(ObjectiveMechanism, list))=None,
                 origin_objective_mechanism=False,
                 terminal_objective_mechanism=False,
                 function:tc.optional(tc.any(is_function_type))=None,
                 search_function:tc.optional(tc.any(is_function_type))=None,
                 search_termination_function:tc.optional(tc.any(is_function_type))=None,
                 search_space:tc.optional(tc.any(list, np.ndarray))=None,
                 control_signals:tc.optional(tc.any(is_iterable, ParameterState, ControlSignal))=None,
                 modulation:tc.optional(_is_modulation_param)=ModulationParam.MULTIPLICATIVE,
                 params=None,
                 name=None,
                 prefs:is_pref_set=None,
                 **kwargs):
        '''Abstract class that implements OptimizationControlMechanism'''

        if kwargs:
                for i in kwargs.keys():
                    raise OptimizationControlMechanismError("Unrecognized arg in constructor for {}: {}".
                                                            format(self.__class__.__name__, repr(i)))
        self.agent_rep = agent_rep
        self.search_function = search_function
        self.search_termination_function = search_termination_function
        self.search_space = search_space

        # Assign args to params and functionParams dicts (kwConstants must == arg names)
        params = self._assign_args_to_param_dicts(input_states=feature_predictors,
                                                  feature_function=feature_function,
                                                  origin_objective_mechanism=origin_objective_mechanism,
                                                  terminal_objective_mechanism=terminal_objective_mechanism,
                                                  params=params)

        super().__init__(system=None,
                         objective_mechanism=objective_mechanism,
                         function=function,
                         control_signals=control_signals,
                         modulation=modulation,
                         params=params,
                         name=name,
                         prefs=prefs)

    def _validate_params(self, request_set, target_set=None, context=None):
        '''Insure that specification of ObjectiveMechanism has projections to it'''

        super()._validate_params(request_set=request_set, target_set=target_set, context=context)

        from psyneulink.core.compositions.composition import Composition
        if self.agent_rep is None:
            raise OptimizationControlMechanismError("The {} arg of an {} must be specified ({} or a {})".
                                                    format(repr(AGENT_REP), self.__class__.__name__,
                                                           Composition.__name__, FunctionApproximator.__name__))

        elif not isinstance(self.agent_rep, (Composition, FunctionApproximator)):
            raise OptimizationControlMechanismError("The {} arg of an {} must be either a {} or a {}".
                                                    format(repr(AGENT_REP), self.__class__.__name__,
                                                    Composition.__name__, FunctionApproximator.__name__))

        # if isinstance(self.agent_rep, FunctionApproximator) and self.feature_predictors is None:
        #     raise OptimizationControlMechanismError("{} arg for {} must be specified".
        #                                             format(repr(FEATURE_PREDICTORS),
        #                                                    self.__class__.__name__))

    def _instantiate_input_states(self, context=None):
        """Instantiate input_states for Projections from features and objective_mechanism.

        Inserts InputState specification for Projection from ObjectiveMechanism as first item in list of
        InputState specifications generated in _parse_feature_specs from the **feature_predictors** and
        **feature_function** arguments of the ModelFreeOptimizationControlMechanism constructor.
        """

        if isinstance(self.agent_rep, FunctionApproximator):
            self.input_states = self._parse_feature_specs(self.input_states, self.feature_function)

            # Insert primary InputState for outcome from ObjectiveMechanism;
            #     assumes this will be a single scalar value and must be named OUTCOME by convention of ControlSignal
            self.input_states.insert(0, {NAME:OUTCOME, PARAMS:{INTERNAL_ONLY:True}}),

            # Configure default_variable to comport with full set of input_states
            self.instance_defaults.variable, ignore = self._handle_arg_input_states(self.input_states)

        super()._instantiate_input_states(context=context)


        # KAM Removed the exception below 11/6/2018 because it was rejecting valid
        # monitored_output_state spec on ObjectiveMechanism

        # if (OBJECTIVE_MECHANISM in request_set and
        #         isinstance(request_set[OBJECTIVE_MECHANISM], ObjectiveMechanism)
        #         and not request_set[OBJECTIVE_MECHANISM].path_afferents):
        #     raise OptimizationControlMechanismError("{} specified for {} ({}) must be assigned one or more {}".
        #                                             format(ObjectiveMechanism.__name__, self.name,
        #                                                    request_set[OBJECTIVE_MECHANISM],
        #                                                    repr(MONITORED_OUTPUT_STATES)))

    def _instantiate_control_signal(self, control_signal, context=None):
        '''Implement ControlSignalCosts.DEFAULTS as default for cost_option of ControlSignals
        OptimizationControlMechanism requires use of at least one of the cost options
        '''
        control_signal = super()._instantiate_control_signal(control_signal, context)

        if control_signal.cost_options is None:
            control_signal.cost_options = ControlSignalCosts.DEFAULTS
            control_signal._instantiate_cost_attributes()
        return control_signal

    def _instantiate_attributes_after_function(self, context=None):
        '''Instantiate OptimizationControlMechanism's OptimizatonFunction attributes'''

        super()._instantiate_attributes_after_function(context=context)

        # Assign parameters to function (OptimizationFunction) that rely on OptimizationControlMechanism
        self.function_object.reinitialize({DEFAULT_VARIABLE: self.control_allocation,
                                           OBJECTIVE_FUNCTION: self.evaluation_function,
                                           SEARCH_FUNCTION: self.search_function,
                                           SEARCH_TERMINATION_FUNCTION: self.search_termination_function,
                                           SEARCH_SPACE: self.get_control_allocation_search_space()})

        # self.evaluation_function = self.function_object.objective_function
        self.search_function = self.function_object.search_function
        self.search_termination_function = self.function_object.search_termination_function
        self.search_space = self.function_object.search_space

        if isinstance(self.agent_rep, FunctionApproximator):
            self._instantiate_function_approximator_as_agent()
        else:
            self._instantiate_composition_as_agent()

    def get_control_allocation_search_space(self):

        control_signal_sample_lists = []
        for control_signal in self.control_signals:
            control_signal_sample_lists.append(control_signal.allocation_samples)

        # Construct control_allocation_search_space:  set of all permutations of ControlProjection allocations
        #                                     (one sample from the allocationSample of each ControlProjection)
        # Reference for implementation below:
        # http://stackoverflow.com/questions/1208118/using-numpy-to-build-an-array-of-all-combinations-of-two-arrays
        self.control_allocation_search_space = \
            np.array(np.meshgrid(*control_signal_sample_lists)).T.reshape(-1,len(self.control_signals))

        # Insure that ControlSignal in each sample is in its own 1d array
        re_shape = (self.control_allocation_search_space.shape[0], self.control_allocation_search_space.shape[1], 1)
        return self.control_allocation_search_space.reshape(re_shape)

    def _execute(self, variable=None, runtime_params=None, context=None):
        '''Find control_allocation that optimizes evaluation_function.'''

        if (self.context.initialization_status == ContextFlags.INITIALIZING):
            return defaultControlAllocation

        # FIX: WAS NEEDED FOR MODEL_FREE;  OK FOR MODEL_BASED?
        assert variable == self.variable, 'PROGRAM ERROR: variable != self.variable for MFOCM'
        if self.control_allocation is None:
            self.value = [c.instance_defaults.variable for c in self.control_signals]
        # FIX END

        self.state_rep = self.agent_rep.get_state_rep(context=self.context)

        try:
            self.update_agent(self.state_rep, self.control_allocation, self.net_outcome)
        except AttributeError:
            self.update_agent(self.state_rep, self.control_allocation, [0])


        # Compute control_allocation using ModelFreeOptimizationControlMechanism's optimization function
        # IMPLEMENTATION NOTE: skip ControlMechanism._execute since it is a stub method that returns input_values
        control_allocation, self.metric_optimal, self.saved_samples, self.saved_values = \
                                        super(ControlMechanism, self)._execute(variable=self.control_allocation,
                                                                               runtime_params=runtime_params,
                                                                               context=context)
        self.agent_rep.after_execution(context=context)

        return control_allocation

    def evaluation_function(self, control_allocation):
        '''Compute metric for a given control_allocation.
        Assigned as the `objective_function <OptimizationFunction.objective_function>` parameter of the
        `ObjectiveFunction` assigned to the OptimizationControlMechanism's `function
        <OptimizationControlMechanism.function>`.

        Returns a scalar that is the predicted outcome of the `function_approximator
        <ModelFreeOptimizationControlMechanism.function_approximator>`.
        '''
        num_estimates = 1
        return self.evaluate_agent(control_allocation,
                                   num_estimates,
                                   self.state_rep,
                                   context=self.function_object.context)

    # ******************************************************************************************************************
    # FIX: THIS IS FROM ORIG MODEL_BASED IMPLEMENTATION
    # ******************************************************************************************************************

    def apply_control_signal_values(self, control_allocation, runtime_params, context):
        '''Assign specified control_allocation'''
        for i in range(len(control_allocation)):
            if self.value is None:
                self.value = self.instance_defaults.value
            self.value[i] = np.atleast_1d(control_allocation[i])

        self._update_output_states(self.value, runtime_params=runtime_params, context=ContextFlags.COMPOSITION)

    def _instantiate_composition_as_agent(self):
        self.evaluate_agent = self.agent_rep.run_simulation
        # Model-based implementation does not need to update model of the agent, since Composition *is* the agent
        self.update_agent = lambda x,y,z : None

    # ******************************************************************************************************************
    # FIX:  THE FOLLOWING IS SPECIFIC TO ORIG MODEL-FREE (FUNCTION_APPROXIMATOR) IMPLEMENTATION
    # ******************************************************************************************************************

    def _instantiate_function_approximator_as_agent(self):
        '''Instantiate attributes for ModelFreeOptimizationControlMechanism's function_approximator'''

        # Assign parameters to learning_function
        if isinstance(self.agent_rep, type):
            self.agent_rep = self.function_approximator(owner=self)
        else:
            self.agent_rep.initialize(owner=self)

        self.evaluate_agent = self.agent_rep.make_prediction
        # FIX: CAN GET RID OF THIS AND JUST CALL parameterization_fuction directly ONCE CONTROL SIGNALS ARE STATEFUL
        self.update_agent = self.agent_rep.update_weights
        # FIX: SHOULD BE THIS ZZZ
        # self.update_agent = self.agent_rep.parameterization_function

    # FIX: THIS SHOULD BE MERGED WITH HANDLING OF PredictionMechanisms FOR ORIG MODEL-BASED APPROACH;
    # FIX: SHOULD BE GENERALIZED AS SOMETHING LIKE update_state_rep

    tc.typecheck
    def add_features(self, feature_predictors):
        '''Add InputStates and Projections to ModelFreeOptimizationControlMechanism for feature_predictors used to
        predict `net_outcome <ControlMechanism.net_outcome>`

        **feature_predictors** argument can use any of the forms of specification allowed for InputState(s),
            as well as a dictionary containing an entry with *SHADOW_EXTERNAL_INPUTS* as its key and a
            list of `ORIGIN` Mechanisms and/or their InputStates as its value.
        '''

        feature_predictors = self._parse_feature_specs(feature_predictors=feature_predictors,
                                                 context=ContextFlags.COMMAND_LINE)
        self.add_states(InputState, feature_predictors)

    @tc.typecheck
    def _parse_feature_specs(self, feature_predictors, feature_function, context=None):
        """Parse entries of feature_predictors into InputState spec dictionaries

        For InputState specs in SHADOW_EXTERNAL_INPUTS ("shadowing" an Origin InputState):
            - Call _parse_shadow_input_spec

        For standard InputState specs:
            - Call _parse_state_spec
            - Set INTERNAL_ONLY entry of params dict of InputState spec dictionary to True

        Assign functions specified in **feature_function** to InputStates for all feature_predictors

        Returns list of InputState specification dictionaries
        """

        parsed_features = []

        if not isinstance(feature_predictors, list):
            feature_predictors = [feature_predictors]

        for spec in feature_predictors:

            # e.g. {SHADOW_EXTERNAL_INPUTS: [A]}
            if isinstance(spec, dict):
                if SHADOW_EXTERNAL_INPUTS in spec:
                    #  composition looks for node.shadow_external_inputs and uses it to set external_origin_sources
                    self.shadow_external_inputs = spec[SHADOW_EXTERNAL_INPUTS]
                    spec = self._parse_shadow_inputs_spec(spec, feature_function)
                else:
                    raise OptimizationControlMechanismError("Incorrect specification ({}) "
                                                                     "in feature_predictors argument of {}."
                                                                     .format(spec, self.name))
            # e.g. Mechanism, OutputState
            else:
                spec = _parse_state_spec(state_type=InputState, state_spec=spec)    # returns InputState dict
                spec[PARAMS][INTERNAL_ONLY] = True
                if feature_function:
                    spec[PARAMS][FUNCTION] = feature_function
                spec = [spec]   # so that extend works below

            parsed_features.extend(spec)

        return parsed_features

    @tc.typecheck
    def _parse_shadow_inputs_spec(self, spec:dict, fct:tc.optional(Function)):
        ''' Return a list of InputState specifications for the inputs specified in value of dict

        For any other specification, specify an InputState with a Projection from the sender of any Projections
            that project to the specified item
        If FUNCTION entry, assign as Function for all InputStates specified in SHADOW_EXTERNAL_INPUTS
        '''

        input_state_specs = []

        shadow_spec = spec[SHADOW_EXTERNAL_INPUTS]

        if not isinstance(shadow_spec, list):
            shadow_spec = [shadow_spec]
        for item in shadow_spec:
            if isinstance(item, Mechanism):
                # Shadow all of the InputStates for the Mechanism
                input_states = item.input_states
            if isinstance(item, InputState):
                # Place in a list for consistency of handling below
                input_states = [item]
            # Shadow all of the Projections to each specified InputState
            input_state_specs.extend([
                {
                    #NAME:i.name + ' of ' + i.owner.name,
                    VARIABLE: i.variable}
                for i in input_states
            ])
        if fct:
            for i in input_state_specs:
                i.update({FUNCTION:fct})

        return input_state_specs



