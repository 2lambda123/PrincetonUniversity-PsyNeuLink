# Princeton University licenses this file to You under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.  You may obtain a copy of the License at:
#     http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
# on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.


# **************************************  OptimizationControlMechanism *************************************************

"""

Overview
--------

An OptimizationControlMechanism is an abstract class for subclasses of `ControlMechanism <ControlMechanism>` that
use an `OptimizationFunction` to find an `allocation_policy <ControlMechanism.allocation_policy>` --Â 
that is, a `variable <ControlSignal.variable>` for each of its `ControlSignals <ControlSignal>` -- that optimizes the
`objective_function <OptimizationFunction.objective_function>` used by its `OptimizationFunction`.

.. _OptimizationControlMechanism_Creation:

Creating an OptimizationControlMechanism
----------------------------------------

An OptimizationControlMechanism can be created in the same was as any `ControlMechanism <ControlMechanism>`.  The only
constraint is that an `OptimizationFunction` (or one that has the same structure) must be specified as the **function**
argument of its constructor.  In addition, a **learning_function** can be specified (see `below
<OptimizationControlMechanism_Learning_Function>`)

.. _OptimizationControlMechanism_Structure:

Structure
---------

An OptimizationControlMechanism has the same structure as a `ControlMechanism`, including a `Projection <Projection>`
to its `primary InputState <InputState_Primary>` from its associated `objective_mechanism
<ControlMechanism.objective_mechanism>`, that it seeks to optimize.  In addition to its primary `function
<OptimizationControlMechanism.function>`, which is an `OptimizationFunction`, it may also have a `learning_function
<OptimizationControlMechanism.learning_function>`, both of which are described below.

.. _OptimizationControlMechanism_Learning_Function:

Learning Function
^^^^^^^^^^^^^^^^^

An OptimizationControlMechanism may have a `learning_function <OptimizationControlMechanism.learning_function>`
used to generate a model that attempts to predict the value of its `objective_function
<OptimizationControlMechanism.objective_function>` for a given `allocation_policy <ControlMechanism.allocation_policy>`
from a `prediction_vector <OptimizationControlMechanism.prediction_vector>`; it is up to the subclass of the
OptimizationControlMechanism to determine the contents of `prediction_vector
<OptimizationControlMechanism.prediction_vector>`. The `learning_function
<OptimizationControlMechanism.learning_function>` takes as its first argument the `prediction_vector
<OptimizationControlMechanism.prediction_vector>`) and, as its second, `outcome <ControlMechanism.outcome>` minus
the `cost <ControlSignal.cost>` of its `control_signals <ControlMechanism.control_signals>`.  It returns an array
with one weight for each element of `prediction_vector <OptimizationControlMechanism.prediction_vector>`, that is
assigned as the OptimizationControlMechanism's `prediction_weights <OptimizationControlMechanism.prediction_weights>`)
attribute.  This is can be used by its primary `function <OptimizationControlMechanism.function>` in seeking to
optimze the OptimizationControlMechanism's `allocation_policy <ControlMechanism.allocation_policy>` (see `below
<OptimizationControlMechanism_Function>).

.. _OptimizationControlMechanism_Function:

*Primary Function*
^^^^^^^^^^^^^^^^^^

The `function <OptimizationControlMechanism.function>` of an OptimizationControlMechanism is generally an
`OptimizationFunction`, which in turn has `objective_function <OptimizationFunction.objective_function>`,
`search_function <OptimizationFunction.search_function>` and `search_termination_function
<OptimizationFunction.search_termination_function>` methods, as well as a `search_space
<OptimizationFunction.search_space>` attribute.  The `objective_function <OptimizationFunction.objective_function>`
is used to evaluate each `allocation_policy <ControlMechanism.allocation_policy>` generated by the `search_function
<OptimizationFunction.search_function>`, and return the one that optimizes the value of the `objective_function
<OptimizationFunction.objective_function>`.

An OptimizationControlMechanism must implement an `objective_function <OptimizationControlMechanism>` method that
is passed to the `OptimizationFunction` as its `objective_function <OptimizationFunction.objective_function>` parameter.
The OptimizationControlMechanism may also implement `search_function <OptimizationControlMechanism.search_function>`
and `search_termination_function <OptimizationControlMechanism.search_termination_function>` methods, as well as a
`search_space <OptimizationControlMechanism.search_space>` attribute, which will also be passed as parameters to the
`OptimizationFunction` when it is constructed.  Any or all of these assignments can be overriden by specifying the
relevant parameters in a constructor for the `OptimizationFunction` assigned to the **function** argument of the
OptimizationControlMechanism's constructor, as long as they are compatible with the requirements of the
OptimizationFunction and OptimizationControlMechanism.  A custom function can also be assigned as the `function
<OptimizationControlMechanism.function>` of an OptimizationControlMechanism, however it must meet the following
requirements:

.. _OptimizationControlMechanism_Custom_Funtion:

    - it must accept as its first argument and return as its result an array with the same shape as the
      OptimizationControlMechanism's `allocation_policy <ControlMechanism.allocation_policy>`.

    - it must implement a :method:`reinitialize` method that accepts as keyword arguments **objective_function**,
      **search_function**, **search_termination_function**, and **search_space**, and implement attributes
      with corresponding names.

.. _OptimizationControlMechanism_Execution:

Execution
---------

When an OptimizationControlMechanism executes, it calls its `learning_function
<OptimizationControlMechanism.learning_function>` if it has one, to udpate its prediction model, and then calls
its primary `function <OptimizationControlMechanism.function>` to find the `allocation_policy
<ControlMechanism.allocation_policy>` that optimizes the value of its `objective_function
<OptimizationControlMechanism.objective_function>`. The values in the `allocation_policy
<OptimizationControlMechanism.allocation_policy>` returned by `function <OptimizationControlMechanism.function>` are
assigned as the `variables <ControlSignal.variable>` of its `control_signals <ControlMechanism.control_signals>`,
from which they compute their `values <ControlSignal.value>`.

COMMENT:
.. _OptimizationControlMechanism_Examples:

Example
-------
COMMENT

.. _OptimizationControlMechanism_Class_Reference:

Class Reference
---------------

"""
import typecheck as tc

import numpy as np

from psyneulink.core.components.functions.function import \
    ModulationParam, _is_modulation_param, is_function_type, OBJECTIVE_FUNCTION, \
    SEARCH_SPACE, SEARCH_FUNCTION, SEARCH_TERMINATION_FUNCTION
from psyneulink.core.components.mechanisms.adaptive.control.controlmechanism import ControlMechanism
from psyneulink.core.components.mechanisms.processing.objectivemechanism import \
    ObjectiveMechanism, MONITORED_OUTPUT_STATES
from psyneulink.core.components.states.parameterstate import ParameterState
from psyneulink.core.components.states.modulatorysignals.controlsignal import ControlSignalCosts, ControlSignal
from psyneulink.core.globals.keywords import \
    DEFAULT_VARIABLE, PARAMETER_STATES, OBJECTIVE_MECHANISM, OPTIMIZATION_CONTROL_MECHANISM
from psyneulink.core.globals.preferences.componentpreferenceset import is_pref_set
from psyneulink.core.globals.preferences.preferenceset import PreferenceLevel
from psyneulink.core.globals.utilities import is_iterable

__all__ = [
    'OptimizationControlMechanism', 'OptimizationControlMechanismError'
]

class OptimizationControlMechanismError(Exception):
    def __init__(self, error_value):
        self.error_value = error_value

    def __str__(self):
        return repr(self.error_value)

    
class OptimizationControlMechanism(ControlMechanism):
    """OptimizationControlMechanism(                       \
    objective_mechanism=None,                              \
    learning_function=None,                                \
    objective_function=None,                               \
    search_function=None,                                  \
    search_termination_function=None,                      \
    search_space=None,                                     \
    function=None,                                         \
    control_signals=None,                                  \
    modulation=ModulationParam.MULTIPLICATIVE,             \
    params=None,                                           \
    name=None,                                             \
    prefs=None)

    Subclass of `ControlMechanism <ControlMechanism>` that adjusts its `ControlSignals <ControlSignal>` to optimize
    performance of the `Composition` to which it belongs

    Arguments
    ---------

    objective_mechanism : ObjectiveMechanism or List[OutputState specification]
        specifies either an `ObjectiveMechanism` to use for the OptimizationControlMechanism, or a list of the 
        `OutputState <OutputState>`\\s it should monitor; if a list of `OutputState specifications
        <ObjectiveMechanism_Monitored_Output_States>` is used, a default ObjectiveMechanism is created and the list
        is passed to its **monitored_output_states** argument.

    learning_function : LearningFunction, function or method
        specifies a function used to predict `outcome <ControlMechanism.outcome> minus the `costs <ControlSignal.cost>`
        of the `control_signals <ControlMechanism.control_signals>` from `prediction_vector
        <OptimizationControlMechanism.prediction_vector>` (see `OptimizationControlMechanism_Learning_Function`
        for details).

    objective_function : function or method
        specifies the function assigned to `function <OptimizationControlMechanism.function>` as its 
        `objective_function <OptimizationFunction.objective_function>` parameter, unless that is specified in a 
        constructor for `function <OptimizationControlMechanism.function>`. It must take as its first argument 
        an array with the same shape as the OptimizationControlMechanism's `allocation_policy
        <ControlMechanism.allocation_policy>`, and return the following four values: an array containing the 
        `allocation_policy <ControlMechanism.allocation_policy>` that generated the optimal value of the function;
        an array containing that optimal value;  a list containing each `allocation_policy 
        <ControlMechanism.allocation_policy>` sampled if `function <OptimizationControlMechanism.function>` has a
        a `save_samples <OptimizationFunction.save_samples>` attribute and it is `True`, otherwise `None`; and a list
        containing the value of the function for `allocation_policy <ControlMechanism.allocation_policy>` sampled if
        it has a `save_values <OptimizationFunction.save_values>` attribute and it is `True`, otherwise `None`.

    search_function : function or method
        specifies the function assigned to `function <OptimizationControlMechanism.function>` as its 
        `search_function <OptimizationFunction.search_function>` parameter, unless that is specified in a 
        constructor for `function <OptimizationControlMechanism.function>`.  It must take as its arguments 
        an array with the same shape as `allocation_policy <ControlMechanism.allocation_policy>` and an integer
        (indicating the iteration of the `optimization process <OptimizationFunction_Process>`), and return 
        an array with the same shape as `allocation_policy <ControlMechanism.allocation_policy>`.

    search_termination_function : function or method
        specifies the function assigned to `function <OptimizationControlMechanism.function>` as its 
        `search_termination_function <OptimizationFunction.search_termination_function>` parameter, unless that is 
        specified in a constructor for `function <OptimizationControlMechanism.function>`.  It must take as its 
        arguments an array with the same shape as `allocation_policy <ControlMechanism.allocation_policy>` and two 
        integers (the first representing the value of `objective_function 
        <OptimizationControlMechanism.objective_function>` for the current `allocation_policy 
        <ControlMechanism.allocation_policy>` and the second the current iteration of the `optimization process 
        <OptimizationFunction_Process>`;  it must return `True` or `False`.
        
    search_space : list or ndarray
        specifies the `search_space <OptimizationFunction.search_space>` parameter for `function 
        <OptimizationControlMechanism.function>`, unless that is specified in a constructor for `function 
        <OptimizationControlMechanism.function>`.  Each item must have the same shape as `allocation_policy 
        <ControlMechanism.allocation_policy>`.
        
    function : OptimizationFunction, function or method
        specifies the function used to optimize the `allocation_policy`;  must take as its sole argument an array
        with the same shape as `allocation_policy <ControlMechanism.allocation_policy>`, and return a similar
        array (see `Primary Function <OptimizationControlMechanism>` for
        additional details).

    control_signals : ControlSignal specification or List[ControlSignal specification, ...]
        specifies the parameters to be controlled by the OptimizationControlMechanism
        (see `ControlSignal_Specification` for details of specification).

    params : Dict[param keyword: param value] : default None
        a `parameter dictionary <ParameterState_Specification>` that can be used to specify the parameters for the
        Mechanism, its `learning_function <OptimizationControlMechanism.learning_function>`, and/or a custom function and its parameters.  Values
        specified for parameters in the dictionary override any assigned to those parameters in arguments of the
        constructor.

    name : str : default see `name <OptimizationControlMechanism.name>`
        specifies the name of the OptimizationControlMechanism.

    prefs : PreferenceSet or specification dict : default Mechanism.classPreferences
        specifies the `PreferenceSet` for the OptimizationControlMechanism; see `prefs
        <OptimizationControlMechanism.prefs>` for details.

    Attributes
    ----------

    prediction_vector : 1d ndarray
        array passed to `learning_function <OptimizationControlMechanism.learning_function>` if that is implemented.

    prediction_weights : 1d ndarray
        weights assigned to each term of `prediction_vector <OptimizationControlMechanism.prediction_vector>`
        by `learning_function <OptimizationControlMechanism.learning_function>`.

    learning_function : LearningFunction, function or method
        takes `prediction_vector <OptimizationControlMechanism.prediction_vector>` as its first argument, and `outcome
        <ControlMechanism.outcome> minus the `costs <ControlSignal.cost>` of the `control_signals
        <ControlMechanism.control_signals>` as its second argument, and returns an updated set of `prediction_weights
        <OptimizationControlMechanism.prediction_weights>` (see `OptimizationControlMechanism_Learning_Function` for
        additional details).

    objective_function : function or method
        `objective_function <OptimizationFunction.objective_function>` assigned to `function 
        <OptimizationControlMechanism.function>`.  
        
    search_function : function or method
        `search_function <OptimizationFunction.search_function>` assigned to `function 
        <OptimizationControlMechanism.function>`.

    search_termination_function : function or method
        `search_termination_function <OptimizationFunction.search_termination_function>` assigned to
        `function <OptimizationControlMechanism.function>`.        
        
    search_space : list or ndarray
        `search_space <OptimizationFunction.search_space>` assigned to `function 
        <OptimizationControlMechanism.function>`.

    function : OptimizationFunction, function or method
        takes current `control_signal_variables <OptimiziationControlMechanism.control_signal_variables>`
        and returns an `allocation_policy` that optimizes the value of its `objective_function
        <OptimizationControlMechanism.objective_function>`  (see `Primary Function
        <OptimizationControlMechanism_Function>` for additional details).

    saved_samples : list
        contains all values of `allocation_policy <ControlMechanism.allocation_policy>` sampled by `function
        <OptimizationControlMechanism.function>` if its `save_samples <OptimizationFunction.save_samples>` parameter
        is `True`;  otherwise list is empty.

    saved_values : list
        contains all values of the `objective_function <OptimizationControlMechanism.objective_function>` sampled
        by `function <OptimizationControlMechanism.function>` if its
        `save_values <OptimizationFunction.save_samples>` parameter is `True`;  otherwise list is empty.

    control_signal_variables : np.array
        variables of the OptimizationControlMechanism's `control_signals
        <ControlMechanism.control_signals>`.

    name : str
        name of the OptimizationControlMechanism; if it is not specified in the **name** argument of the constructor, a
        default is assigned by MechanismRegistry (see `Naming` for conventions used for default and duplicate names).

    prefs : PreferenceSet or specification dict
        the `PreferenceSet` for the OptimizationControlMechanism; if it is not specified in the **prefs** argument of
        the constructor, a default is assigned using `classPreferences` defined in __init__.py (see :doc:`PreferenceSet
        <LINK>` for details).
    """

    componentType = OPTIMIZATION_CONTROL_MECHANISM
    # initMethod = INIT_FULL_EXECUTE_METHOD
    # initMethod = INIT_EXECUTE_METHOD_ONLY

    classPreferenceLevel = PreferenceLevel.SUBTYPE
    # classPreferenceLevel = PreferenceLevel.TYPE
    # Any preferences specified below will override those specified in TypeDefaultPreferences
    # Note: only need to specify setting;  level will be assigned to Type automatically
    # classPreferences = {
    #     kwPreferenceSetName: 'DefaultControlMechanismCustomClassPreferences',
    #     kp<pref>: <setting>...}

    # FIX: ADD OTHER Params() HERE??
    class Params(ControlMechanism.Params):
        function = None

    paramClassDefaults = ControlMechanism.paramClassDefaults.copy()
    paramClassDefaults.update({PARAMETER_STATES: NotImplemented}) # This suppresses parameterStates

    @tc.typecheck
    def __init__(self,
                 objective_mechanism:tc.optional(tc.any(ObjectiveMechanism, list))=None,
                 origin_objective_mechanism=False,
                 terminal_objective_mechanism=False,
                 learning_function=None,
                 function:tc.optional(tc.any(is_function_type))=None,
                 search_function:tc.optional(tc.any(is_function_type))=None,
                 search_termination_function:tc.optional(tc.any(is_function_type))=None,
                 search_space:tc.optional(tc.any(list, np.ndarray))=None,
                 control_signals:tc.optional(tc.any(is_iterable, ParameterState, ControlSignal))=None,
                 modulation:tc.optional(_is_modulation_param)=ModulationParam.MULTIPLICATIVE,
                 params=None,
                 name=None,
                 prefs:is_pref_set=None,
                 **kwargs):
        '''Abstract class that implements OptimizationControlMechanism'''

        if kwargs:
                for i in kwargs.keys():
                    raise OptimizationControlMechanismError("Unrecognized arg in constructor for {}: {}".
                                                            format(self.__class__.__name__, repr(i)))
        self.learning_function = learning_function
        self.search_function = search_function
        self.search_termination_function = search_termination_function
        self.search_space = search_space

        # Assign args to params and functionParams dicts (kwConstants must == arg names)
        params = self._assign_args_to_param_dicts(origin_objective_mechanism=origin_objective_mechanism,
                                                  terminal_objective_mechanism=terminal_objective_mechanism,
                                                  params=params)

        super().__init__(system=None,
                         objective_mechanism=objective_mechanism,
                         function=function,
                         control_signals=control_signals,
                         modulation=modulation,
                         params=params,
                         name=name,
                         prefs=prefs)

    def _validate_params(self, request_set, target_set=None, context=None):
        '''Insure that specification of ObjectiveMechanism has projections to it'''

        super()._validate_params(request_set=request_set, target_set=target_set, context=context)

        if (OBJECTIVE_MECHANISM in request_set and
                isinstance(request_set[OBJECTIVE_MECHANISM], ObjectiveMechanism)
                and not request_set[OBJECTIVE_MECHANISM].path_afferents):
            raise OptimizationControlMechanismError("{} specified for {} ({}) must be assigned one or more {}".
                                                    format(ObjectiveMechanism.__name__, self.name,
                                                           request_set[OBJECTIVE_MECHANISM],
                                                           repr(MONITORED_OUTPUT_STATES)))

    def _instantiate_control_signal(self, control_signal, context=None):
        '''Implement ControlSignalCosts.DEFAULTS as default for cost_option of ControlSignals
        OptimizationControlMechanism requires use of at least one of the cost options
        '''
        control_signal = super()._instantiate_control_signal(control_signal, context)

        if control_signal.cost_options is None:
            control_signal.cost_options = ControlSignalCosts.DEFAULTS
            control_signal._instantiate_cost_attributes()
        return control_signal

    def _instantiate_attributes_after_function(self, context=None):
        '''Instantiate OptimizationControlMechanism attributes and assign parameters to learning_function & function'''

        super()._instantiate_attributes_after_function(context=context)

        # Instantiate attributes for OptimizationControlMechanism
        self.control_signal_variables = np.array([c.variable for c in self.control_signals])

        if self.learning_function:
            self._instantiate_learning_function()

        # Assign parameters to function (OptimizationFunction) that rely on OptimizationControlMechanism
        self.function_object.reinitialize({DEFAULT_VARIABLE: self.control_signal_variables,
                                           OBJECTIVE_FUNCTION: self.objective_function,
                                           SEARCH_FUNCTION: self.search_function,
                                           SEARCH_TERMINATION_FUNCTION: self.search_termination_function,
                                           SEARCH_SPACE: self.get_control_signal_search_space()})
        
        self.objective_function = self.function_object.objective_function
        self.search_function = self.function_object.search_function
        self.search_termination_function = self.function_object.search_termination_function
        self.search_space = self.function_object.search_space
        

    def _execute(self, variable=None, runtime_params=None, context=None):
        '''Find allocation_policy that optimizes objective_function.'''

        raise OptimizationControlMechanismError("PROGRAM ERROR: {} must implement its own {} method".
                                                format(self.__class__.__name__, repr('_execute')))

    def get_control_signal_search_space(self):

        control_signal_sample_lists = []
        for control_signal in self.control_signals:
            control_signal_sample_lists.append(control_signal.allocation_samples)

        # Construct control_signal_search_space:  set of all permutations of ControlProjection allocations
        #                                     (one sample from the allocationSample of each ControlProjection)
        # Reference for implementation below:
        # http://stackoverflow.com/questions/1208118/using-numpy-to-build-an-array-of-all-combinations-of-two-arrays
        self.control_signal_search_space = \
            np.array(np.meshgrid(*control_signal_sample_lists)).T.reshape(-1,len(self.control_signals))

        # Insure that ControlSignal in each sample is in its own 1d array
        re_shape = (self.control_signal_search_space.shape[0], self.control_signal_search_space.shape[1], 1)

        return self.control_signal_search_space.reshape(re_shape)

    def objective_function(self, allocation_policy):
        '''Compute outcome for a given allocation_policy.'''

        raise OptimizationControlMechanismError("PROGRAM ERROR: {} must implement an {} method".
                                                format(self.__class__.__name__, repr('objective_function')))

