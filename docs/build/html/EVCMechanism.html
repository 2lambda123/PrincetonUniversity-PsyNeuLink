

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>EVC Mechanism &mdash; PsyNeuLink 0.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="PsyNeuLink 0.1 documentation" href="index.html"/>
        <link rel="up" title="Control Mechanisms" href="ControlMechanism.html"/>
        <link rel="next" title="Monitoring Mechanisms" href="MonitoringMechanism.html"/>
        <link rel="prev" title="Default Control Mechanism" href="DefaultControlMechanism.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> PsyNeuLink
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="System.html">System</a></li>
<li class="toctree-l1"><a class="reference internal" href="Process.html">Process</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Mechanism.html">Mechanisms</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="ProcessingMechanism.html">Processing Mechanisms</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="ControlMechanism.html">Control Mechanisms</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="DefaultControlMechanism.html">Default Control Mechanism</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">EVC Mechanism</a></li>
<li class="toctree-l3"><a class="reference internal" href="ControlMechanism.html#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="ControlMechanism.html#creating-a-controlmechanism">Creating A ControlMechanism</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="MonitoringMechanism.html">Monitoring Mechanisms</a></li>
<li class="toctree-l2"><a class="reference internal" href="Mechanism.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="Mechanism.html#creating-a-mechanism">Creating a Mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="Mechanism.html#structure">Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="Mechanism.html#execution">Execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="Mechanism.html#class-reference">Class Reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="State.html">States</a></li>
<li class="toctree-l1"><a class="reference internal" href="Projection.html">Projections</a></li>
<li class="toctree-l1"><a class="reference internal" href="Utilities.html">Utilities</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">PsyNeuLink</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
          <li><a href="Mechanism.html">Mechanisms</a> &raquo;</li>
      
          <li><a href="ControlMechanism.html">Control Mechanisms</a> &raquo;</li>
      
    <li>EVC Mechanism</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/EVCMechanism.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-EVCMechanism">
<span id="evc-mechanism"></span><h1>EVC Mechanism<a class="headerlink" href="#module-EVCMechanism" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="EVCMechanism.ControlSignalChannel">
<em class="property">class </em><code class="descclassname">EVCMechanism.</code><code class="descname">ControlSignalChannel</code><span class="sig-paren">(</span><em>inputState</em>, <em>variableIndex</em>, <em>variableValue</em>, <em>outputState</em>, <em>outputIndex</em>, <em>outputValue</em><span class="sig-paren">)</span><a class="headerlink" href="#EVCMechanism.ControlSignalChannel" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="EVCMechanism.ControlSignalChannel.inputState">
<code class="descname">inputState</code><a class="headerlink" href="#EVCMechanism.ControlSignalChannel.inputState" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="attribute">
<dt id="EVCMechanism.ControlSignalChannel.outputIndex">
<code class="descname">outputIndex</code><a class="headerlink" href="#EVCMechanism.ControlSignalChannel.outputIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 4</p>
</dd></dl>

<dl class="attribute">
<dt id="EVCMechanism.ControlSignalChannel.outputState">
<code class="descname">outputState</code><a class="headerlink" href="#EVCMechanism.ControlSignalChannel.outputState" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 3</p>
</dd></dl>

<dl class="attribute">
<dt id="EVCMechanism.ControlSignalChannel.outputValue">
<code class="descname">outputValue</code><a class="headerlink" href="#EVCMechanism.ControlSignalChannel.outputValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 5</p>
</dd></dl>

<dl class="attribute">
<dt id="EVCMechanism.ControlSignalChannel.variableIndex">
<code class="descname">variableIndex</code><a class="headerlink" href="#EVCMechanism.ControlSignalChannel.variableIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="attribute">
<dt id="EVCMechanism.ControlSignalChannel.variableValue">
<code class="descname">variableValue</code><a class="headerlink" href="#EVCMechanism.ControlSignalChannel.variableValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="EVCMechanism.EVCMechanism">
<em class="property">class </em><code class="descclassname">EVCMechanism.</code><code class="descname">EVCMechanism</code><span class="sig-paren">(</span><em>default_input_value=NotImplemented</em>, <em>function=&lt;PsyNeuLink.Functions.Utilities.Utility.LinearCombination object&gt;</em>, <em>make_default_controller: bool = True</em>, <em>save_all_values_and_policies: bool = False</em>, <em>monitored_output_states: &lt;typecheck.framework.optional object at 0x10c1653c8&gt; = None</em>, <em>cost_aggregation_function=&lt;PsyNeuLink.Functions.Utilities.Utility.LinearCombination object&gt;</em>, <em>cost_application_function=&lt;PsyNeuLink.Functions.Utilities.Utility.LinearCombination object&gt;</em>, <em>prediction_mechanism_type=&lt;class 'PsyNeuLink.Functions.Mechanisms.ProcessingMechanisms.AdaptiveIntegrator.AdaptiveIntegratorMechanism'&gt;</em>, <em>prediction_mechanism_params: &lt;typecheck.framework.optional object at 0x10bf61dd8&gt; = None</em>, <em>params=None</em>, <em>name=None</em>, <em>prefs: &lt;function is_pref_set at 0x10b613378&gt; = None</em>, <em>context='EVCMechanism INITIALIZING '</em><span class="sig-paren">)</span><a class="headerlink" href="#EVCMechanism.EVCMechanism" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximize EVC over specified set of control signals for values of monitored states</p>
<blockquote>
<div><dl class="docutils">
<dt>Description:</dt>
<dd><ul class="first simple">
<li>Implements EVC maximization (Shenhav et al. 2013)</li>
</ul>
<p>[DOCUMENATION HERE:]</p>
<p>NOTE: self.function serves as kwValueAggregationFunction
ALTERNATIVE:  IMPLEMENT FOLLOWING IN paramClassDefaults:</p>
<blockquote>
<div><dl class="docutils">
<dt>kwValueAggregationFunction:</dt>
<dd><dl class="first last docutils">
<dt>LinearCombination(</dt>
<dd><dl class="first docutils">
<dt>param_defaults={OFFSET:0,</dt>
<dd>SCALE:1,
OPERATION:LinearCombination.Operation.SUM},</dd>
</dl>
<p class="last">context=functionType+kwValueAggregationFunction),</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p class="last"># INSTANTIATION:
# - specification of system:  required param: SYSTEM
# - kwDefaultController:  True =&gt;
#         takes over all projections from default Controller;
#         does not take monitored states (those are created de-novo)
# TBI: - CONTROL_SIGNAL_PROJECTIONS:
#         list of projections to add (and for which outputStates should be added)
# - inputStates: one for each performance/environment variable monitiored</p>
</dd>
</dl>
</div></blockquote>
<p># DOCUMENT:
# 1) Add a predictionMechanism for each origin (input) Mechanism in self.system,
#        and a Process for each pair: [origin, IDENTITY_MATRIX, prediction]
# 2) Implement self.simulatedSystem that, for each originMechanism
#        replaces Process.inputState with predictionMechanism.value
# 3) Modify EVCMechanism.update() to execute self.simulatedSystem rather than self.system
#    CONFIRM: EVCMechanism.system is never modified in a way that is not reflected in EVCMechanism.simulatedSystem
#                (e.g., when learning is implemented)
# 4) Implement controlSignal allocations for optimal allocation policy in EVCMechanism.system</p>
<dl class="docutils">
<dt># ARGS/ PARAMS:</dt>
<dd># # Assigns EVCMechanism, when instantiated, as the DefaultController
# MAKE_DEFAULT_CONTROLLER:True,
# # Saves all ControlAllocationPolicies and associated EVC values (in addition to max)
# kwSaveAllValuesAndPolicies: False,
# # Can be replaced with a list of OutputStates or Mechanisms
# #     the values of which are to be monitored
# MONITORED_OUTPUT_STATES: [MonitoredOutputStatesOption.PRIMARY_OUTPUT_STATES],
# # function and params specifies value aggregation function
# FUNCTION: LinearCombination,
# FUNCTION_PARAMS: {OFFSET: 0,
#                    SCALE: 1,
#                    # Must be a vector with length = length of MONITORED_OUTPUT_STATES
#                    # WEIGHTS: [1],
#                    OPERATION: LinearCombination.Operation.PRODUCT},
# # CostAggregationFunction specifies how costs are combined across ControlSignals
# # kwWeight can be added, in which case it should be equal in length
# #     to the number of outputStates (= ControlSignal Projections)
# kwCostAggregationFunction:
#                 LinearCombination(offset=0.0,
#                                   scale=1.0,
#                                   operation=LinearCombination.Operation.SUM,
#                                   context=functionType+kwCostAggregationFunction),
# # CostApplicationFunction specifies how aggregated cost is combined with
# #     aggegated value computed by function to determine EVC
# kwCostApplicationFunction:
#                  LinearCombination(offset=0.0,
#                                    scale=1,
#                                    operation=LinearCombination.Operation.SUM,
#                                    context=functionType+kwCostApplicationFunction),
# # Mechanism class used for prediction mechanism(s)
# # Note: each instance will be named based on origin mechanism + kwPredictionMechanism,
# #       and assigned an outputState named based on the same
# kwPredictionMechanismType:AdaptiveIntegratorMechanism,
# # Params passed to PredictionMechanismType on instantiation
# # Note: same set will be passed to all PredictionMechanisms
# kwPredictionMechanismParams:{MONITORED_OUTPUT_STATES:None}</dd>
</dl>
<p># NOTE THAT EXCECUTE METHOD ~ ValueAggregationFunction (i.e,. analogous to CostAggregationFunction</p>
<p># DESCRIBE USE OF MonitoredOutputStatesOptions VS. EXPLICIT SPECIFICADTION OF MECHANISM AND/OR STATES
# CAN SPECIFIY WEIGHTS IF LIST OF MECHANISMS/ STATES IS PROVIDED, IN WHICH CASE #WEIGHTS MUST = #STATES SPECIFIED
#              OTHEREWISE (IF MonitoredOutputStatesOptions OR DEFAULT IS USED, WEIGHTS ARE IGNORED</p>
<p># GET FROM System AND/OR Mechanism
#     MONITORED_OUTPUT_STATES must be list of Mechanisms or OutputStates in Mechanisms that are in SYSTEM
#     if Mechanism is specified in MONITORED_OUTPUT_STATES, all of its outputStates are used
#     MONITORED_OUTPUT_STATES assigns a Mapping Projection from each outputState to a new inputState in self.inputStates
#     function uses LinearCombination to apply a set of weights to the value of each monitored state to compute EVC and
#     then searches space of control signals (using allocationSamples for each) to find combiantion that maxmizes EVC</p>
<blockquote>
<div><blockquote>
<div>this is overridden if None is specified for MONITORED_OUTPUT_STATES in the outputState itself</div></blockquote>
<p>#    - wherever a ControlSignal projection is specified, using kwEVC instead of CONTROL_SIGNAL
#        this should override the default sender kwSystemDefaultController in ControlSignal._instantiate_sender
#    ? expclitly, in call to &#8220;EVC.monitor(input_state, parameter_state=NotImplemented) method
# - specification of function: default is default allocation policy (BADGER/GUMBY)
#     constraint:  if specified, number of items in variable must match number of inputStates in INPUT_STATES
#                  and names in list in kwMonitor must match those in INPUT_STATES</p>
</div></blockquote>
<p>#      OBJECTIVE FUNCTION FOR exeuteMethod:
#      Applies linear combination to values of monitored states (self.inputStates)
#      function is LinearCombination, with weights = linear terms
#      FUNCTION_PARAMS = WEIGHTS
#      Cost is aggregated over controlSignal costs using kwCostAggregationFunction (default: LinearCombination)</p>
<blockquote>
<div>currently, it is specified as an instantiated function rather than a reference to a class</div></blockquote>
<dl class="docutils">
<dt>#      Cost is combined with values (aggregated by function) using kwCostApplicationFunction</dt>
<dd><dl class="first last docutils">
<dt>(          default: LinearCombination)</dt>
<dd><blockquote class="first">
<div><blockquote>
<div>currently, it is specified as an instantiated function rather than a reference to a class</div></blockquote>
<p># EVALUATION:
# - function with one variable item (1D array) for each inputState
# - mapping projections from monitored states to inputStates
# - control signal projections established automatically by system implementation (using kwConrolSignal)
#
# EXECUTION:
# - call system.execute for each point in search space
# - compute evaluation function, and keep track of performance outcomes</p>
</div></blockquote>
<dl class="last docutils">
<dt>Class attributes:</dt>
<dd><ul class="first last">
<li><p class="first">functionType (str): System Default Mechanism</p>
</li>
<li><dl class="first docutils">
<dt>paramClassDefaults (dict):</dt>
<dd><ul class="first last simple">
<li>SYSTEM (System)</li>
<li>MONITORED_OUTPUT_STATES (list of Mechanisms and/or OutputStates)</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>Class methods:</dt>
<dd>None</dd>
<dt>Instance attributes:</dt>
<dd><dl class="first docutils">
<dt>system (System):</dt>
<dd>System of which EVCMechanism is component, and that it executes to determine the EVC</dd>
</dl>
<p>predictionMechanisms (list): list of predictionMechanisms added to System for self.system.originMechanisms
predictionProcesses (list): list of prediction Processes added to System
controlSignalSearchSpace (list of np.ndarrays):</p>
<blockquote>
<div>list of all combinations of all allocationSamples for all ControlSignal Projections
for all outputStates in self.outputStates;
each item in the list is an np.ndarray, the dimension of which is the number of self.outputStates</div></blockquote>
<dl class="docutils">
<dt>MonitoredOutputStates (list): each item is a OutputState that sends a projection to a corresponding</dt>
<dd>inputState in the ordered dict self.inputStates</dd>
</dl>
<p>monitoredValues (3D np.nparray): values of monitored states (self.inputStates) from call of self.function
EVCmax (2D np.array):</p>
<blockquote>
<div>values of monitored states (self.inputStates) for EVCmax</div></blockquote>
<dl class="last docutils">
<dt>EVCmaxPolicy (1D np.array):</dt>
<dd>vector of values (ControlSignal allocations) for EVCmax, one for each outputState in self.outputStates</dd>
</dl>
</dd>
<dt>Instance methods:</dt>
<dd><ul class="first">
<li><dl class="first docutils">
<dt>_validate_params(request_set, target_set, context):</dt>
<dd><p class="first last">insure that SYSTEM is specified, and validate specifications for monitored states</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>_validate_monitored_state(item):</dt>
<dd><p class="first last">validate that all specifications for a monitored state are either a Mechanism or OutputState</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>_instantiate_attributes_before_function(context):</dt>
<dd><p class="first last">assign self.system and monitoring states (inputStates) specified in MONITORED_OUTPUT_STATES</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>instantiate_monitored_output_states(monitored_states, context):</dt>
<dd><p class="first last">parse list of OutputState(s) and/or Mechanism(s) and call instantiate_monitoring_input_state for each item</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>instantiate_monitoring_input_state(output_state, context):</dt>
<dd><p class="first last">extend self.variable to accomodate new inputState
create new inputState for outputState to be monitored, and assign Mapping Project from it to inputState</p>
</dd>
</dl>
</li>
</ul>
<dl class="docutils">
<dt>-&nbsp;instantiate_control_signal_projection(projection, context):</dt>
<dd>adds outputState, and assigns as sender of to requesting ControlSignal Projection</dd>
</dl>
<ul class="last">
<li><dl class="first docutils">
<dt>_instantiate_function(context):</dt>
<dd><p class="first last">construct self.controlSignalSearchSpace from the allocationSamples for the
ControlSignal Projection associated with each outputState in self.outputStates</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>update(time_scale, runtime_params, context)</dt>
<dd><dl class="first last docutils">
<dt>execute System for each combination of controlSignals in self.controlSignalSearchSpace,</dt>
<dd><p class="first last">store output values in self.EVCvalues, identify and store maximum in self.EVCmax,
store the corresponding combination of ControlSignal allocations self.EVCmaxPolicy,
and assign those allocations to outputState.values</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>execute(params, time_scale, context):</dt>
<dd><p class="first last">execute self.system for a combination of controlSignals from self.controlSignalSearchSpace</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>add_monitored_state(state, context):</dt>
<dd><p class="first last">validates state as Mechanism or OutputState specification;
adds inputState to self.inputStates with Mapping Projection from state
Note:  used by other objects to add outputState(s) to be monitored by EVC</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="EVCMechanism.EVCMechanism.instantiate_prediction_mechanisms">
<code class="descname">instantiate_prediction_mechanisms</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#EVCMechanism.EVCMechanism.instantiate_prediction_mechanisms" title="Permalink to this definition">¶</a></dt>
<dd><p>Add prediction Process for each origin (input) Mechanism in System</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>context</strong> &#8211; </td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="EVCMechanism.EVCMechanism.instantiate_monitoring_input_state">
<code class="descname">instantiate_monitoring_input_state</code><span class="sig-paren">(</span><em>monitored_state</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#EVCMechanism.EVCMechanism.instantiate_monitoring_input_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiate inputState with projection from monitoredOutputState</p>
<p>Validate specification for outputState to be monitored
Instantiate inputState with value of monitoredOutputState
Instantiate Mapping projection to inputState from monitoredOutputState</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>monitored_state</strong> (<a class="reference internal" href="OutputState.html#module-OutputState" title="OutputState"><em>OutputState</em></a>) &#8211; </li>
<li><strong>context</strong> &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="EVCMechanism.EVCMechanism.get_simulation_system_inputs">
<code class="descname">get_simulation_system_inputs</code><span class="sig-paren">(</span><em>phase</em><span class="sig-paren">)</span><a class="headerlink" href="#EVCMechanism.EVCMechanism.get_simulation_system_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return array of predictionMechanism values for use as inputs to processes in simulation run of System</p>
<p>Returns: 2D np.array</p>
</dd></dl>

<dl class="method">
<dt id="EVCMechanism.EVCMechanism.add_monitored_states">
<code class="descname">add_monitored_states</code><span class="sig-paren">(</span><em>states_spec</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#EVCMechanism.EVCMechanism.add_monitored_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate and then instantiate outputStates to be monitored by EVC</p>
<p>Use by other objects to add a state or list of states to be monitored by EVC
states_spec can be a Mechanism, OutputState or list of either or both
If item is a Mechanism, each of its outputStates will be used
All of the outputStates specified must be for a Mechanism that is in self.System</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>(Mechanism, MechanimsOutputState or list of either or both</strong> (<em>states_spec</em>) &#8211; </li>
<li><strong>context</strong> &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="EVCMechanism.EVCMechanism.LinearCombination">
<em class="property">class </em><code class="descname">LinearCombination</code><span class="sig-paren">(</span><em>variable_default=[2, 2], scale: &lt;function parameter_spec at 0x10b63fa60&gt; = 1.0, offset: &lt;function parameter_spec at 0x10b63fa60&gt; = 0.0, exponents: &lt;function is_numerical_or_none at 0x10b5e58c8&gt; = None, weights: &lt;function is_numerical_or_none at 0x10b5e58c8&gt; = None, operation: &lt;typecheck.tc_predicates.enum object at 0x10b6380b8&gt; = 'sum', params=None, prefs: &lt;function is_pref_set at 0x10b613378&gt; = None, context='LinearCombination INITIALIZING '</em><span class="sig-paren">)</span><a class="headerlink" href="#EVCMechanism.EVCMechanism.LinearCombination" title="Permalink to this definition">¶</a></dt>
<dd><p>Linearly combine arrays of values with optional weighting, offset, and/or scaling</p>
<dl class="docutils">
<dt>Description:</dt>
<dd><p class="first">Combine corresponding elements of arrays in variable arg, using arithmetic operation determined by OPERATION
Use optional WEIGHTING argument to weight contribution of each array to the combination
Use optional SCALE and OFFSET parameters to linearly transform the resulting array
Returns a list or 1D array of the same length as the individual ones in the variable</p>
<p>Notes:
* If variable contains only a single array, it is simply linearly transformed using SCALE and OFFSET
* If there is more than one array in variable, they must all be of the same length
* WEIGHTS can be:</p>
<blockquote class="last">
<div><ul class="simple">
<li>1D: each array in the variable is scaled by the corresponding element of WEIGHTS)</li>
<li>2D: each array in the variable is multiplied by (Hadamard Product) the corresponding array in kwWeight</li>
</ul>
</div></blockquote>
</dd>
<dt>Initialization arguments:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>variable (value, np.ndarray or list): values to be combined;</dt>
<dd><p class="first last">can be a list of lists, or a 1D or 2D np.array;  a 1D np.array is always returned
if it is a list, it must be a list of numbers, lists, or np.arrays
all items in the list or 2D np.array must be of equal length
the length of WEIGHTS (if provided) must equal the number of arrays (2nd dimension; default is 2)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>params (dict) can include:</dt>
<dd><ul class="first last">
<li><p class="first">WEIGHTS (list of numbers or 1D np.array): multiplies each variable before combining them (default: [1, 1])</p>
</li>
<li><p class="first">OFFSET (value): added to the result (after the arithmetic operation is applied; default is 0)</p>
</li>
<li><p class="first">SCALE (value): multiples the result (after combining elements; default: 1)</p>
</li>
<li><dl class="first docutils">
<dt>OPERATION (Operation Enum) - method used to combine terms (default: SUM)</dt>
<dd><p class="first last">SUM: element-wise sum of the arrays in variable
PRODUCT: Hadamard Product of the arrays in variable</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>LinearCombination.execute returns combined values:
- single number if variable was a single number
- list of numbers if variable was list of numbers
- 1D np.array if variable was a single np.variable or np.ndarray</p>
<dl class="method">
<dt id="EVCMechanism.EVCMechanism.LinearCombination.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=NotImplemented</em>, <em>params=NotImplemented</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#EVCMechanism.EVCMechanism.LinearCombination.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Linearly combine a list of values, and optionally offset and/or scale them</p>
<dl class="docutils">
<dt># DOCUMENT:</dt>
<dd><p class="first">Handles 1-D or 2-D arrays of numbers
Convert to np.array
All elements must be numeric
If linear (single number or 1-D array of numbers) just apply scale and offset
If 2D (array of arrays), apply exponents to each array
If 2D (array of arrays), apply weights to each array
Operators:  SUM AND PRODUCT
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
OLD:
Variable must be a list of items:</p>
<blockquote>
<div><ul class="simple">
<li>each item can be a number or a list of numbers</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Corresponding elements of each item in variable are combined based on OPERATION param:</dt>
<dd><ul class="first last simple">
<li>SUM adds corresponding elements</li>
<li>PRODUCT multiples corresponding elements</li>
</ul>
</dd>
<dt>An initializer (kwLinearCombinationInitializer) can be provided as the first item in variable;</dt>
<dd>it will be populated with a number of elements equal to the second item,
each element of which is determined by OPERATION param:
- for SUM, initializer will be a list of 0&#8217;s
- for PRODUCT, initializer will be a list of 1&#8217;s</dd>
<dt>Returns a list of the same length as the items in variable,</dt>
<dd>each of which is the combination of their corresponding elements specified by OPERATION</dd>
</dl>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">var variable:</th><td class="field-body">(list of numbers) - values to calculate (default: [0, 0]:</td>
</tr>
<tr class="field-even field"><th class="field-name">params:</th><td class="field-body">(dict) with entries specifying:
EXPONENTS (2D np.array): exponentiate each value in the variable array (default: none)
WEIGHTS (2D np.array): multiply each value in the variable array (default: none):
OFFSET (scalar) - additive constant (default: 0):
SCALE: (scalar) - scaling factor (default: 1)
OPERATION: LinearCombination.Operation - operation to perform (default: SUM):</td>
</tr>
<tr class="field-odd field"><th class="field-name">return:</th><td class="field-body">(1D np.array)</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="function">
<dt id="EVCMechanism.compute_EVC">
<code class="descclassname">EVCMechanism.</code><code class="descname">compute_EVC</code><span class="sig-paren">(</span><em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#EVCMechanism.compute_EVC" title="Permalink to this definition">¶</a></dt>
<dd><p>compute EVC for a specified allocation policy</p>
<p>IMPLEMENTATION NOTE:  implemented as a function so it can be used with multiprocessing Pool</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ctlr</strong> (<a class="reference internal" href="#module-EVCMechanism" title="EVCMechanism"><em>EVCMechanism</em></a>) &#8211; </li>
<li><strong>allocation_vector</strong> (<em>1D np.array</em>) &#8211; allocation policy for which to compute EVC</li>
<li><strong>runtime_params</strong> (<em>dict</em>) &#8211; runtime params passed to ctlr.update</li>
<li><strong>time_scale</strong> (<em>TimeScale</em>) &#8211; time_scale passed to ctlr.update</li>
<li><strong>context</strong> (<a class="reference internal" href="Projection.html#Projection.Projection_Base.value" title="Projection.Projection_Base.value"><em>value</em></a>) &#8211; context passed to ctlr.update</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Returns (float, float, float):</dt>
<dd>(EVC_current, total_current_value, total_current_control_costs)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="EVCMechanism.random">
<code class="descclassname">EVCMechanism.</code><code class="descname">random</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; x in the interval [0, 1).<a class="headerlink" href="#EVCMechanism.random" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="MonitoringMechanism.html" class="btn btn-neutral float-right" title="Monitoring Mechanisms" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="DefaultControlMechanism.html" class="btn btn-neutral" title="Default Control Mechanism" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Jon Cohen.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>