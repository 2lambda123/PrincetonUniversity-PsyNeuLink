import pytest
import numpy as np

from psyneulink.library.mechanisms.processing.transfer.lcamechanism import LCAMechanism
from psyneulink.components.mechanisms.processing import ProcessingMechanism
from psyneulink.components.mechanisms.processing import TransferMechanism
from psyneulink.components.functions.function import Linear, Logistic, UserDefinedFunction
from psyneulink.components.process import Process
from psyneulink.components.system import System

#

class TestUserDefFunc:

    def test_python_func(self):
        def myFunction(variable, params, context):
            return sum(variable[0]) + 2
        myMech = ProcessingMechanism(function=myFunction, size=4, name='myMech')
        val = myMech.execute(input=[-1, 2, 3, 4])
        assert np.allclose(val, [[10]])

    def test_user_def_func(self):
        def myFunction(variable, params, context):
            return variable * 2 + 3
        U = UserDefinedFunction(custom_function=myFunction, default_variable=[[0, 0]])
        myMech = ProcessingMechanism(function=myFunction, size=2, name='myMech')
        val = myMech.execute([1, 3])

    def test_udf_system_origin(self):
        def myFunction(variable, params, context):
            return [variable[0][1], variable[0][0]]
        myMech = ProcessingMechanism(function=myFunction, size=3, name='myMech')
        T = TransferMechanism(size=2, function=Linear)
        p = Process(pathway=[myMech, T])
        s = System(processes=[p])
        s.run(inputs = {myMech: [[1, 3, 5]]})
        assert np.allclose(s.results[0][0], [3, 1])

    def test_udf_system_terminal(self):
        def myFunction(variable, params, context):
            return [variable[0][2], variable[0][0]]
        myMech = ProcessingMechanism(function=myFunction, size=3, name='myMech')
        T2 = TransferMechanism(size=3, function=Linear)
        p2 = Process(pathway=[T2, myMech])
        s2 = System(processes=[p2])
        s2.run(inputs = {T2: [[1, 2, 3]]})
        assert(np.allclose(s2.results[0][0], [3, 1]))

    def test_udf_with_pnl_func(self):
        L = Logistic(gain=2)

        def myFunction(variable, params, context):
            return L.function(variable) + 2

        U = UserDefinedFunction(custom_function=myFunction, default_variable=[[0, 0, 0]])
        myMech = ProcessingMechanism(function=myFunction, size=3, name='myMech')
        val1 = myMech.execute(input=[1, 2, 3])
        val2 = U.execute(variable=[[1, 2, 3]])
        assert np.allclose(val1, val2)
        assert np.allclose(val1, L.function([1, 2, 3]) + 2)

    def test_udf_creates_parameter_states(self):
        def func(input=[[0], [0]], p=0, q=1):
            return (p + q) * input

        m = ProcessingMechanism(
            default_variable=[[0], [0]],
            function=UserDefinedFunction(func)
        )

        assert len(m.parameter_states) == 2
        assert 'p' in m.parameter_states.names
        assert 'q' in m.parameter_states.names

    @pytest.fixture
    def mech_with_autogenerated_udf(self):
        def func(input=[[0], [0]], p=0, q=1):
            return (p + q) * input

        m = ProcessingMechanism(
            default_variable=[[0], [0]],
            function=UserDefinedFunction(func)
        )

        return m

    def test_autogenerated_udf(self, mech_with_autogenerated_udf):
        assert isinstance(mech_with_autogenerated_udf.function_object, UserDefinedFunction)

    def test_autogenerated_udf_creates_parameter_states(self, mech_with_autogenerated_udf):
        assert len(mech_with_autogenerated_udf.parameter_states) == 2
        assert 'p' in mech_with_autogenerated_udf.parameter_states.names
        assert 'q' in mech_with_autogenerated_udf.parameter_states.names
